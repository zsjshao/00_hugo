+++
author = "zsjshao"
title = "02_进程管理"
date = "2021-01-01"
tags = ["OS"]
categories = ["OS"]

+++

# 进程管理

知识框架

![os](http://images.zsjshao.net/ky/os/2/01.png)

## 1、进程与线程

### 1.1、进程的定义、组成、组织方式和特征

#### 1.1.1、进程的定义

程序：就是一个指令序列

在多道程序环境下,允许多个程序并发执行,此时它们将失去封闭性,并具有间断性及不可再现性的特征。为此引入了进程(Process)的概念以便更好地描述和控制程序的并发执行,实现操作系统的并发性和共享性(最基本的两个特性)

为了使参与并发执行的程序(含数据)能独立地运行,必须为之配置一个专门的数据结构,称为进程控制块(Process Control Block,PCB)系统利用PCB来描述进程的基本情况和运行状态,进而控制和管理进程。相应地,由程序段相关数据段和PCB三部分构成了进程映像(进程实体)所谓创建进程,实质上是创建进程映像中的PCB:而撤销进程,实质上是撤销进程的PCB值得注意的是,进程映像是静态的,进程则是动态的。

注意:PCB是进程存在的唯一标志!

从不同的角度,进程可以有不同的定义,比较典型的定义有:

- 1)进程是程序的一次执行过程
- 2)进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
- 3)进程是具有独立功能的程序在一个数据集合上运行的过程,它是系统进行资源分配和调度的一个独立单位“。

引入进程实体的概念后,我们可以把传统操作系统中的进程定义为：“进程是进程实体的运行过程,是系统进行资源分配和调度的一个独立单位。

这里说的系统资源。它指处理机、存储器和其他设备服务于某个进程的“时间”,例如把处理机资源理解为处理机的时间片才是准确的。因为进程是这些资源分配和调度的独立单位,即“时间片”分配的独立单位,这就决定了进程一定是一个动态的、过程性的概念。

#### 1.1.2、进程的组成

进程是一个独立的运行单位,也是操作系统进行资源分配和调度的基本单位。它由程序段、数据段、PCB三部分组成,其中最核心的是进程控制块(PCB)

![os](http://images.zsjshao.net/ky/os/2/02.png)

![os](http://images.zsjshao.net/ky/os/2/04.png)

##### 1.1.2.1、进程控制块

进程创建时,操作系统为它新建一个PCB,该结构之后**常驻内存**,任意时刻都可以存取,并在进程结束时删除。PCB是进程实体的一部分,是进程存在的唯一标志。

进程执行时,系统通过其PCB了解进程的现行状态信息,以便对其进行控制和管理;进程结束时,系统收回其PCB,该进程随之消亡。操作系统通过PCB表来管理和控制进程

当操作系统欲调度某进程运行时,要从该进程的PCB中查出其现行状态及优先级;在调度到某进程后,要根据其PCB中所保存的处理机状态信息,设置该进程恢复运行的现场,并根据其PCB中的程序和数据的内存始址,找到其程序和数据:进程在运行过程中,当需要和与之合作的进程实现同步、通信或访问文件时,也需要访问PCB当进程由于某种原因而暂停运行时,又需将其断点的处理机环境保存在PCB中,可见,在进程的整个生命期中,系统总是通过PCB对进程进行控制的,亦即系统唯有通过进程的PCB才能感知到该进程的存在

PCB主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等。

![os](http://images.zsjshao.net/ky/os/2/03.png)

![os](http://images.zsjshao.net/ky/os/2/05.png)

1)进程描述信息。进程标识符:标志各个进程,每个进程都有一个唯一的标识号。用户标识符:进程归属的用户,用户标识符主要为共享和保护服务。

2)进程控制和管理信息,进程当前状态:描述进程的状态信息,作为处理机分配调度的依据。进程优先缓:描述进程抢占处理机的优先级,优先级高的进程可优先获得处理机。

3)资源分配清单,用于说明有关内存地址空间或虚拟地址空间的状况,所打开文件的列表和所使用的输入输出设备信息。

4)处理机相关信息,主要指处理机中各寄存器的值,当进程被切换时,处理机状态信息都必须保存在相应的PCB中,以便在该进程重新执行时,能从断点继续执行。

##### 1.1.2.2、程序段

程序段就是能被进程调度程序调度到CPU执行的程序代码段注意,程序可被多个进程共学,即多个进程可以运行同一个程序

##### 1.1.2.3、数据段

一个进程的数据段,可以是进程对应的程序加工处理的原始数据,也可以是程序执行时产生的中间或最终结果。

#### 1.1.3、进程的组织方式

在一个系统中,通常存在着许多进程的PC,有的处于就绪态,有的处于阻塞态,而且阻塞的原因各不相同,为了方便进程的调度和管理,需要将各进程的PCB用适当的方法组织起来。目前,常用的组织方式有链接方式和索引方式两种,链接方式将同一状态的PCB链接成一个队列,不同状态对应不同的队列,也可把处于阻塞态的进程的PCB,根据其阻塞原因的不同,排成多个阻塞队列,索引方式将同一状态的进程组织在一个索引表中,索引表的表项指向相应的PCB,不同状态对应不同的索引表,如就绪索引表和阻塞索引表等。

![os](http://images.zsjshao.net/ky/os/2/06.png)

链接方式

![os](http://images.zsjshao.net/ky/os/2/07.png)

索引方式

![os](http://images.zsjshao.net/ky/os/2/08.png)

#### 1.1.4、进程的特征

进程是由多道程序的并发执行而引出的,它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的,也是对进程管理提出的基本要求

- 1)动态性。进程是程序的一次执行,它有着创建、活动、暂停、终止等过程,具有一定的生命周期,是动志地产生,变化和消亡的,动态性是进程最基本的特征
- 2)并发性。指多个进程实体同时存于内存中,能在一段时间内同时运行,并发性是进程的重要特征,同时也是操作系统的重要特征,引入进程的目的就是为了使程序能与其他进程的程序并发执行,以提高资源利用率
- 3)独立性。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位,凡未建立PCB的程序,都不能作为一个独立的单位参与运行。
- 4)异步性,由于进程的相互制约,使得进程具有执行的间断性,即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性,为此在操作系统中必须配置相应的进程同步机制
- 5)结构性。每个进程都配置一个PCB对其进行描述。从结构上看,进程实体是由程序、数据段和进程控制块三部分组成的。

![os](http://images.zsjshao.net/ky/os/2/09.png)

#### 1.1.5、总结

![os](http://images.zsjshao.net/ky/os/2/10.png)

### 1.2、进程的状态与转换

![os](http://images.zsjshao.net/ky/os/2/11.png)

#### 1.2.1、进程的状态

进程在其生命周期内,由于系统中各进程之间的相互制约关系及系统的运行环境的变化,使得进程的状态也在不断地发生变化(一个进程会经历若干不同状态)。通常进程有以下五种状态,前三种是进程的基本状态。

- 1)运行态。进程正在处理机上运行。在单处理机环境下,每个时刻最多只有一个进程处于运行态
- 2)就绪态,进程获得了除处理机外的一切所需资源,一且得到处理机,便可立即运行素统中处于就绪状态的进程可能有多个,通常将它们排成一个队列,称为就绪队列
- 3)阻塞态,又称等待态。进程正在等待某一事件而暂停运行,如等待某资源为可用(不包括处理机)或等待输入输出完成。即使处理机空闲,该进程也不能运行
- 4)创建态。进程正在被创建,尚未转到就绪态。创建进程通常需要多个步骤:首先申请一个空白的PCB,并向PCB中填写一些控制和管理进程的信息然后由系统为该进程分配运行时所必需的资源;最后把该进程转入就结态。
- 5)结束态。进程正从系统中消失,可能是进程正常结束或其他原因中断退出运行,进程需要结运行时,系统首先必须置该进程为结束态,然后再进一步处理资源释放和回收等工作

注意区别就绪态和等待态:就绪态是指进程仅缺少处理机,只要获得处理机资源就立即运行而等待态是指进程需要其他资源(除了处理机或等待某一事件。

#### 1.2.2、进程状态的转换

![os](http://images.zsjshao.net/ky/os/2/12.png)

需要注意的是,一个进程从运行态变成阻塞态是主动的行为,而从阻塞态变成就绪态是被动的行为,需要其他相关进程的协助

#### 1.2.3、总结

![os](http://images.zsjshao.net/ky/os/2/13.png)

### 1.3、进程控制

![os](http://images.zsjshao.net/ky/os/2/14.png)

进程控制的主要功能是对系统中的所有进程实施有效的管理,它具有创建新进程、撤销已有进程、实现进程状态转换等功能。

简化理解：反正进程控制就是要实现进程状态转换

![os](http://images.zsjshao.net/ky/os/2/15.png)

在操作系统中,一般把进程控制用的程序段称为原语,原语的特点是执行期间不允许中断,只能一气呵成，它是一个不可分割的基本单位。这种不可被中断的操作即原子操作。

原语采用”关中断指令”和“开中断指令”实现

![os](http://images.zsjshao.net/ky/os/2/16.png)

显然，关/开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令。

**进程控制相关的原语**

进程控制会导致进程状态的切换。无论哪个原语，要做的无非三类事情：

- 1.更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）
  - a.所有的进程控制原语一定都会修改进程状态标志
  - b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境
  - c.某进程开始运行前必然要恢复其运行环境
- 2.将PCB插入合适的队列
- 3.分配/回收资源

#### 1.3.1、进程创建

允许一个进程创建另一个进程。此时创建者称为父进程,被创建的进程称为于进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时,应将其从父进程那里获得的资源归还给父进程。此外,在撤销父进程时,必须同时撤销其所有的子进程。

在操作系统中,终端用户登录系统、作业调度系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建一个新进程的过程如下(创建原语)

- 1)为新进程分配一个唯一的进程标识号,并申请一个空白的PCB(PCB是有限的)若PCB申请失败,则创建失败。

- 2)为进程分配资源,为新进程的程序和数据及用户分配必要的内存空间(在PCB中体现)

  注意,若资源不足(如内存空间),则并不是创建失败,而是处于阻塞态,等待内存资源

- 3)初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信总,以及设置进程的优先级等

- 4)若进程就绪队列能够接纳新进程,则将新进程插入就绪队列,等待被调度运行

![os](http://images.zsjshao.net/ky/os/2/17.png)

#### 1.3.2、进程终止

引起进程终止的事件主要有:①正常结束,表示进程的任务已完成并准备退出运行。②异常结束,表示进程在运行时,发生了某种异常事件,使程序无法继续运行,如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/O故障等。③外界干预,指进程应外界的请求而终止运行,如操作员或操作系统干预、父进程请求和父进程终止

操作系统终止进程的过程如下(撤销原语)：

- 1)根据被终止进程的标识符,检索PCB,从中读出该进程的状态
- 2)若被终止进程处于执行状态,立即终止该进程的执行,将处理机资源分配给其他进程
- 3)若该进程还有子孙进程,则应将其所有子孙进程终止
- 4)将该进程所拥有的全部资源,或归还给其父进程,或归还给操作系统
- 5)将该PCB从所在队列(链表)中删除。

![os](http://images.zsjshao.net/ky/os/2/18.png)

#### 1.3.3、进程阻塞和唤醒

正在执行的进程,由于期待的某些事件未发生，如请求系统资源失败,等待某种操作的完成、新数据尚未到达或无新工作可做等,由系统自动执行阻塞原语(Block)，使自己由运行态变为阻塞态。可见，进程的阻塞是进程自身的一种主动行为,也因此只有处于运行态的进程(获得CPU),才可能将其转为阻塞态。

阻塞原语的执行过程如下:

- 1)找到将要被阻塞进程的标识号对应的PCB。
- 2)若该进程为运行态,则保护其现场,将其状态转为阻塞态,停止运行。
- 3)把该PCB插入相应事件的等待队列,将处理机资源调度给其他就绪进程。

当被阻塞进程所期待的事件出现时,如它所启动的I/O操作已完成或其所期待的数据已到达,由有关进程(比如,释放该I/O设备的进程,或提供数据的进程)调用唤醒原语(Wakeup),将等待该事件的进程唤醒。

唤醒原语的执行过程如下:

- 1)在该事件的等待队列中找到相应进程的PCB
- 2)将其从等待队列中移出,并置其状态为就绪态
- 3)把该PCB插入就绪队列,等待调度程序调度。

需要注意的是, Block原语和 Wakeup原语是一对作用刚好相反的原语,必须成对使用, Block原语是由被阻塞进程自我调用实现的,而 Wakeup原语则是由一个与被唤醒进程合作或被其他相关的进程调用实现的

![os](http://images.zsjshao.net/ky/os/2/19.png)

#### 1.3.4、进程切换

对于通常的进程而言,其创建、撤销及要求由系统设备完成的I/O操作,都是利用系统调用而进入内核,再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说,任何进程都是在操作系统内核的支持下运行的,是与内核紧密相关的。

进程切换是指处理机从一个进程的运行转到另一个进程上运行,在这个过程中,进程的运行环境产生了实质性的变化。

进程切换的过程如下:

- 1)保存处理机上下文,包括程序计数器和其他寄存器
- 2)更新PCB信息
- 3)把进程的PCB移入相应的队列,如就绪、在某事件阻塞等队列。
- 4)选择另一个进程执行,并更新其PCB
- 5)更新内存管理的数据结构
- 6)恢复处理机上下文

注意,进程切换与处理机模式切换是不同的,模式切换时,处理机逻辑上可能还在同一进程中运行。若进程因中断或异常进入核心态运行,执行完后又回到用户态刚被中断的程序运行,则操作系统只需恢复进程进入内核时所保存的CPU现场,而无须改变当前进程的环境信息。但若要切换进程,当前运行进程改变了,则当前进程的环境信息也需要改变。

注意:“调度”和“切换”的区别。调度是指决定资源分配给哪个进程的行为,是一种决策行为;切换是指实际分配的行为,是执行行为。一般来说,先有资源的调度,然后才有进程的切换

![os](http://images.zsjshao.net/ky/os/2/20.png)

#### 1.3.5、总结

![os](http://images.zsjshao.net/ky/os/2/21.png)

### 1.4、进程通信

![os](http://images.zsjshao.net/ky/os/2/22.png)

进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。

进程通信是指进程之间的信息交换。PV操作(第3节是低级通信方式,高级通信方式是指以较高的效率传输大量数据的通信方式高级通信方法主要有以下三类

#### 1.4.1、共享存储

在通信的进程之间存在一块可直接访问的共享空间,通过对这片共享空间进行写读操作实现进程之间的信息交换,在对共享空间进行写/读操作时,需要使用同步互斥工具(如P操作、V操作),对共享空间的写读进行控制。

共享存储又分为两种:低级方式的共享是基于数据结构的共享;高级方式的共享则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具,而数据交换则由用户自己安排读写指令完成

![os](http://images.zsjshao.net/ky/os/2/23.png)

基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式

基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。

注意,用户进程空间一般都是独立的,进程运行期间一般不能访问其他进程的空间,要想让两个用户进程共享空间,必须通过特殊的系统调用实现,而进程内的线程是自然共享进程空间的。

#### 1.4.2、管道通信

管道通信是消息传递的一种特殊方式(见图2.4),所谓“管道”,是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件,又名pipe文件,向管道(共享文件)提供输入的发送进程(即写进程),以字符流形式将大量的数据送入(写)管道而接收管道输出的接收进程(即读进程)则从管道中接收(读)数据。

为了协调双方的通信,管道机制必须提供以下三方面的协调能力:互斥、同步和确定对方的存在

![os](http://images.zsjshao.net/ky/os/2/24.png)

下面以 LinuxLinux中的管道为例进行说明。在中,管道是一种使用非常频繁的通信机制从本质上说,管道也是一种文件,但它又和一般的文件有所不同,管道可以克服使用文件进行通信的两个问题,具体表现如下:

- 1)限制管道的大小。实际上,管道是一个固定大小的缓冲区,在 Linux中,该缓冲区的大小为4KB,这使得它的大小不像文件那样不加检验地增长,使用单个固定缓冲区也会带来问题,比如在写管道时可能变满,这种情况发生时,随后对管道的 write调用将默认地被阻塞,等待某些数据被读取,以便腾出足够的空间供 write调用写
- 2)读进程也可能工作得比写进程快,当所有当前进程数据已被读取时,管道变空当这种情况发生时,一个随后的 reado调用将默认地被阻塞,等特某些数据被写入,这解决了 read()调用返回文件结束的问题。

注意:从管道读数据是一次性操作,数据一旦被读取,它就从管道中被抛弃,释放空间以便写更多的数据管道只能采用双工通信,即某一时刻只能单向传输,要实现父子进程双方互动通信,需要定义两个管道

管道可以理解为共享存储的优化和发展,因为在共享存储中,若某进程要访问共享存储空间,则必须没有其他进程在该共享存储空间中进行写操作,否则访问行为就会被阻塞。而管道通信中,存储空间进化成了缓冲区,缓冲区只允许一边写入、另一边读出,因此只要缓冲区中有数据,进程就能从缓冲区中读出,而不必担心会因为其他进程在其中进行写操作而遭到阻塞,因为写进程会先把缓冲区写满,然后才让读进程读,当缓冲区中还有数据时,写进程不会往缓冲区写数据。当然,这也决定了管道通信必然是半双工通信。

#### 1.4.3、消息传递

在消息传递系统中,进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间,则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。

- 1)直接通信方式。发送进程直接把消息发送给接收进程,并将它挂在接收进程的消息缓冲队列上,接收进程从消息缓冲队列中取得消息
- 2)间接通信方式发送进程把消息发送到某个中间实体,接收进程从中间实体取得消息这种中间实体一般称为信箱,这种通信方式又称信箱通信方。该通信方式广泛应用于计算机网络中,相应的通信系统称为电子邮件系统。

简单理解就是,甲要告诉乙某些事情,就要写信,然后通过邮差送给乙。直接通信就是邮差把信直接送到乙的手上;间接通信就是乙家门口有一个邮箱,邮差把信放到邮箱里

![os](http://images.zsjshao.net/ky/os/2/25.png)

#### 1.4.4、总结

![os](http://images.zsjshao.net/ky/os/2/26.png)

### 1.5、线程、多线程模型

![os](http://images.zsjshao.net/ky/os/2/27.png)

#### 1.5.1、线程的基本概念

引入进程的目的是为了更好地使多道程序并发执行,提高资源利用率和系统吞吐量:而引入线程的目的则是为了减小程序在井发执行时所付出的时空开销,提高操作系统的并发性能。

线程最直接的理解就是“轻量级进程”,它是一个基本的CPU执行单元,也是程序执行流的最小单元,由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体,是被系统独立调度和分派的基本单位,线程自己不拥有系统资源,只拥有一点儿在运行中必不可少的资源,但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程,同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约,致使线程在运行中呈现出间断性,线程也有就绪、阻塞和运行三种基本状态。

引入线程后,进程的内涵发生了改变,进程只作为除CPU外的系统资源的分配单元,而线程则作为处理机的分配单元。由于一个进程内部有多个线程,若线程的切换发生在同一个进程内部,则只需要很少的时空开销。

#### 1.5.2、线程与进程的比较

1)调度。在传统的操作系统中,拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中,线程是独立调度的基本单位,进程是拥有资源的基本单位。在同一进程中,线程的切换不会引起进程切换,在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时,会引起进程切换。

2)拥有资源。不论是传统操作系统还是设有线程的操作系统,进程都是拥有资源的基本位,而线程不拥有系统资源(也有一点儿必不可少的资源),但线程可以访问其隶属进程的系统资源。要知道,若线程也是拥有资源的单位,则切换线程就需要较大的时空开销,线程这个概念的提出就没有意义

3)并发性在引入线程的操作系统中不仅进程之间可以并发执行,而且多个线程之间也可以并发执行,从而使操作系统具有更好的并发性提高了系统的吞吐量

4)系统开销。由于创建或撤销进程时,系统都要为之分配或回收资源,如内存空间、I/O设备等,因此操作系统所付出的开销远大于创建或撤销线程时的开销,类似地,在进行进程切换时,涉及当前执行进程CPU环境的保存及新调度到进程CPU环境的设置,而线程切换时只需保存和设置少量寄存器内容,开销很小此外,由于同一进程内的多个线程共享进程的地址空间,因此这些线程之间的同步与通信非常容易实现,甚至无须操作系统的干预

5)地址空间和其他资源(如打开的文件)进程的地址空间之间互相独立,同一进程的各线程间共享进程的资源,某进程内的线程对于其他进程不可见

6)通信方面。进程间通信(IPC)需要进程同步和互斥手段的辅助,以保证数据的一致性,而线程间可以直接读写进程数据段(如全局变量)来进行通信

#### 1.5.3、线程的属性

多线程操作系统把线程作为独立运行(或调度)的基本单位,此时的进程已不再是一个基本的可执行实体,但它仍具有与执行相关的状态。所谓进程处于“执行”状态,实际上是指该进程中的某线程正在执行,线程的主要属性如下：

- 1)线程是一个轻型实体,它不拥有系统资源,但每个线程都应有一个唯一的标识符和一个线程控制块,线程控制块记录了线程执行的寄存器和栈等现场状态
- 2)不同的线程可以执行相同的程序,即同一个服务程序被不同的用户调用时,操作系统把它们创建成不同的线程
- 3)同一进程中的各个线程共享该进程所拥有的资源。
- 4)线程是处理机的独立调度单位,多个线程是可以并发执行的。在单CPU的计算机系统中,各线程可交替地占用CPU;在多CPU的计算机系统中,各线程可同时占用不同的CPU若各个CPU同时为一个进程内的各线程服务则可缩短进程的处理时间
- 5)一个线程被创建后,便开始了它的生命周期直至终止线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化

![os](http://images.zsjshao.net/ky/os/2/28.png)

为什么线程的提出有利于提高系统并发性?可以这样来理解:由于有了线程,线程切换时,有可能会发生进程切换,也有可能不发生进程切换,平均而言每次切换所需的开销就变小了,因此能够让更多的线程参与并发,而不会影响到响应时间等问题

#### 1.5.4、线程的实现方式

线程的实现可以分为两类:用户级线程(User-Level Thread,ULT)和内核级线程(Kemel-Level-Thread,KLT).内核级线程又称内核支持的线程.

在用户级线程中,有关线程管理(线程的创建、撤消和切换等)的所有工作都由应用程序完成,内核意识不到线程的存在,应用程序可以通过使用线程库设计成多线程程序。通常,应用程序从单线程开始,在该线程中开始运行,在其运行的任何时刻,可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程,图(a)说明了用户级线程的实现方式

在内核级线程中,线程管理的所有工作由内核完成,应用程序没有进行线程管理的代码,只有一个到内核级线程的编程接口,内核为进程及其内部的每个线程维护上下文信息,调度也在内核基于线程架构的基础上完成图(b)说明了内核级线程的实现方式

有些系统中使用组合方式的多线程实现,线程创建完全在用户空间中完成,线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些(小于等于用户级线程的数目)内核级线程上。图(c)说明了用户级与内核级的组合实现方式

![os](http://images.zsjshao.net/ky/os/2/29.png)

#### 1.5.5、多线程模型

有些系统同时支持用户线程和内核线程,由此产生了不同的多线程模型，即实现用户级线程和内核线程的连接方式

1)多对一模型,将多个用户级线程映射到一个内核级线程,线程管理在用户空间完成。此模式中,用户级线程对操作系统不可见(即透明)

- 优点;线程管理是在用户空间进行的,因而效率比较高
- 缺点:一个线程在使用内核服务时被阻塞,整个进程都会被阻塞:多个线程不能并行地运行在多处理机上

2)一对一模型。将每个用户级线程映射到一个内核级线程

- 优点:当一个线程被阻塞后,允许另一个线程继续执行,所以并发能力较强
- 缺点:每创建一个用户级线程都需要创建一个内核级线程与其对应,这样创建线程的开销比较大,会影响到应用程序的性能

3)多对多模型。将n个用户级线程映射到m个内核级线程上,要求m≤n

- 特点:多对多模型是多对一模型和一对模型的折中,既克服了多对一模型并发度不高的缺点,又克服了一对一模型的一个用户进程占用太多内核级线程而开销太大的缺点。此外,还拥有多对一模型和一对一模型各自的优点,可谓集两者之所长。

#### 1.5.6、总结

![os](http://images.zsjshao.net/ky/os/2/30.png)

### 1.6、小结

1)为什么要引入进程?

在多道程序同时运行的背景下,进程之间需要共享系统资源,因此会导致各程序在执行过程中出现相互制约的关系,程序的执行会表现出间断性的特征,这些特征都是在程序的执行过程中发生的,是动态的过程,而传统的程序本身是一组指令的集合,是一个静态的概念,无法描述程序在内存中的执行情况,即我们无法从程序的字面上出它何时执行、何时停顿,也无法看出它与其他执行程序的关系,因此,程序这个静态概念已不能如实反映程序并发执行过程的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行,人们引入了进程的概念

2)什么是进程?进程由什么组成?

进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源,是一个动态的概念,是一个活动的实体。它不只是程序的代码本身,还包括当前的活动通过程序计数器的值和处理寄存器的内容来表示

一个进程实体由程序段、相关数据段和PCB三部分构成,其中PCB是标志一个进程存在的唯一标识,程序段是进程运行的程序的代码,数据段则存储程序运行过程中相关的一些数据

3)进程是如何解决问题的?

进程把能够识别程序运行态的一些变量存放在PCB中,通过这些变量系统能够更好地了解进程的状况,并在适当时进行进程的切换以避免一些资源的浪费,甚至划分为更小的调度单位线程来提高系统的并发度。

本节主要介什么是进程,并围绕这个问题进行一些阐述和讨论,为下一节讨论的内容做铺垫,但之前未学过相关课程的读者可能会比较费解,到现在为止对进程这个概念还未形成比较清晰的认识接下来,我们再用一个比较熟悉的概念来类比进程,以大家能彻底理解本节的内容到底在讲什么,到底解决了什么问题

我们用“人的生命历程”来类比进程。首先,人的生命历程一定是一个动态的、过程性的概念,要研究人的生命历程,先要介绍经历这个历程的主体是什么,主体当然是人,相当于经历进程的主体是进程映像,人有自己的身份,相当于进程映像里有PCB;人生历程会经历好几种状态:出生的时候、弥留的时候、充满斗志的时候、发奋图强的时候及失落的时候,相当于进程有创建、撤销、就绪、运行、阻塞等状态,这几种状态会发生改变,人会充满斗志而转向发奋图强,发图强获得进步之后又会充满斗志预备下一次发奋图强,或者发奋图强后遇到阻碍会进入失落状态,然后在别人的开导之下又重新充满斗志类比进程,会由就绪态转向运行态,运行态转向就绪态,或者运行态转向阻塞态,然后在别的进程帮助下返回就绪态。

若我们用“人生历程”这个过程的概念去类比进程,则对进程的理解就会更深一层。前面生活化的例子可以帮我们理解进程的实质,但它毕竟有不严谨的地方。一种较好的方式是,在类比进程和“人生历程”后,再看一遍前面较为严谨的书面述和讨论,这样对知识的掌握会更加准确而全面.

这里再给出一些学习计算机科学知识的建议。学习科学知识时,很多同学会陷入一个误区,即只注重对定理、公式的应用,而忽视对基础概念的理解。这是我们从小到大为了应付考试而培养出的一个毛病,因为熟练应用公式和定理考试有立竿见影的效果。公式、定理的应用固然重要,但基础概念的理解能让我们透彻地理解一门学科,更利于我们产生兴趣,培养创造性思维。

本节的知识架构图如下:

![os](http://images.zsjshao.net/ky/os/2/31.png)

### 1.7、习题

#### 1.7.1、单项选择题

**1.一个进程映像是()**

A.由协处理器执行的一个程序
B.一个独立的程序+数据集
C.PCB结构与程序和数据的组合
D.一个独立的程序

**2.下列关于线程的叙述中,正确的是()**

A.线程包含CPU现场,可以独立执行程序
B.每个线程有自己独立的地址空间
C.进程只能包含一个线程
D.线程之间的通信必须使用系统调用函数

**3.进程之间交换数据不能通过()途径进行**

A.共享文件
B.消息传递
C.访问进程地址空间
D.访问共享存储区

**4,进程与程序的根本区别是()**

A.静态和动态特点
B.是不是被调入内存
C.是不是具有就绪,运行和等待三种状态
D.是不是占有处理器

**5.下面的叙述中,正确的是()**

A.进程获得处理器运行是通过调度得到的
B.优先级是进程调度的重要依据,一旦确定不能改动
C.在单处理器系统中,任何时刻都只有一个进程处于运行态
D.进程申请处理器而得不到满足时,其状态变为阻塞态

**6.操作系统是根据()来对并发执行的进程进行控制和管理的**

A.进程的基本状态
B.进程控制块
C.多道程序设计
D.进程的优先权

**7.在任何时刻,一个进程的状态变化()引起另一个进程的状态变化**

A.必定
B.一定不
C.不一定
D.不可能

**8.在单处理器系统中,若同时存在10个进程,则处于就绪队列中的进程最多有()个**

A.1
B.8
C.9
D.10

**9.一个进程释放了一台打印机,它可能会改变()的状态**

A.自身进程
B.输入输出进程
C.另一个等待打印机的进程
D.所有等待打印机的进程

**10.系统进程所请求的一次I/O操作完成后将使进程状态从()**

A.运行态变为就绪态
B.运行态变为阻塞态
C.就绪态变为运行态
D.阻塞态变为就绪态

答案：CACAA BCCCD

**11.一个进程的基本状态可以从其他两种基本状态转变过去,这个基本的状态一定是()**

A.执行状态
B.阻塞态
C.就绪态
D.完成状态

**12.并发进程失去封闭性,是指()**

A.多个相对独立的进程以各自的速度向前推进
B.并发进程的执行结果与速度无关
C.并发进程执行时,在不同时刻发生的错误
D.并发进程共享变量,其执行结果与速度有关

**13.通常用户进程被建立后,()**

A.便一直存在于系统中,直到被操作人员撤销
B.随着进程运行的正常或不正常结束而撤销
C.随着时间片轮转而撤销与建立
D.随着进程的阻塞或者唤醒而销毁与建立

**14.进程在处理器上执行时,()**

A.进程之间是无关的,具有封闭特性
B.进程之间都有交互性,相互依赖、相互制约,具有并发性
C.具有并发性,即同时执行的特性
D.进程之间可能是无关的,但也可能是有交互性的

**15.下面的说法中,正确的是()**

A.不论是系统支持的线程还是用户级线程其切换都需要内核的支持
B.线程是资源分配的单位,进程是调度和分派的单位
C.不管系统中是否有线程,进程都是拥有资源的独立单位
D.在引入线程的系统中,进程仍是资源调度和分派的基本单位

**16.在多对一的线程模型中,当一个多线程进程中的某个线程被阻塞后，（）**

A.该进程的其他线程仍可继续运行
B.整个进程都将阻塞
C.该阻塞线程将被撤销
D.该阻塞线程将永远不可能再执行

**17.用信箱实现进程间互通信息的通信机制要有两个通信原语,它们是().**

A.发送原语和执行原语
B.就绪原语和执行原语
C.发送原语和接收原语
D.就绪原语和接收原语

**18.下列几种关于进程的叙述,()最不符合操作系统对进程的理解**

A.进程是在多程序环境中的完整程序
B.进程可以由程序,数据和PCB描述
C.线程(Thread)是一种特殊的进程
D.进程是程序在一个数据集合上的运行过程，它是系统进行资源分配和调度的一个独立单元

**19.支持多道程序设计的操作系统在运行过程中,不断地选择新进程运行来实现CPU的共享,但其中()不是引起操作系统选择新进程的直接原因**

A.运行进程的时间片用完
B.运行进程出错
C.运行进程要等待某一事件发生
D.有新进程进入就绪态

**20.若一个进程实体由PCB、共享正文段、数据堆段和数据栈段组成,请指出下列C语言程序中的内容及相关数据结构各位于哪一段中**

Ⅰ.全局赋值变量()
Ⅱ.未赋值的局部变量()
Ⅲ.函数调用实参传递值()
Ⅳ.用malloco求动态分配的存储区()
V.常量值(1995、string”)()
Ⅵ.进程的优先级()

A.PCB
B.正文段
C.堆段
D.栈段

答案：CDBDC BCAD BDDCBA

**21.同一程序经过多次创建,运行在不同的数据集上,形成了()的进程** 

A.不同
B.相同
C.同步
D.互斥

**22.系统动态DLL库中的系统线程,被不同的进程所调用,它们是()的线程**

A.不同
B.相同
C.可能不同,也可能相同
D.不能被调用

**23.PCB是进程存在的唯一标志,下列()不属于PCB.**

A.进程ID
B.CPU状态
C.堆栈指针
D.全局变量

**24.一个计算机系统中,进程的最大数主要受到()限制**

A.内存大小
B.用户数目
C.打开的文件数
D.外部设备数量

**25.进程创建完成后会进入一个序列,这个序列称为()**

A.阻塞队列
B.挂起序列
C.就绪队列
D.运行队列

**26.在一个多道系统中,若就绪队列不空,就绪的进程数越多,处理器的效率**

A.越高
B.越低
C.不变
D.不确定

**27.在具有通道设备的单处理器系统中实现并发技术后,()**

A.各进程在某一时刻并行运行,CPU与I/O设备间并行工作
B.各进程在某一时间段内并行运行,CPU与I/O设设备间串行工作
C.各进程在某一时间段内并发运行,CPU与I/O设设备间并行工作
D.各进程在某一时刻并发运行,CPU与I/O设设备间串行工作

**28.进程自身决定()**

A.从运行态到阻塞态
B.从运行态到就绪态
C.从就绪态到运行态
D.从阻塞态到就绪态

**29.对进程的管理和控制使用()**

A.指令
B.原语
C.信号量
D.信箱

**30.【2010统考真题】下列选项中,导致创建新进程的操作是()**

Ⅰ.用户登录成功
Ⅱ.设备分配
Ⅲ.启动程序执行

A.仅Ⅰ和Ⅱ
B.仅Ⅱ和Ⅲ
C.仅Ⅰ和Ⅲ
D.Ⅰ、Ⅱ、Ⅲ

答案：ABDAC CCABC

**31.下面的叙述中,正确的是(**

A.引入线程后,处理器只能在线程间切换
B.引入线程后,处理器仍在进程间切换
C.线程的切换,不会引起进程的切换
D.线程的切换,可能引起进程的切换

**32.下面的叙述中,正确的是()**

A.线程是比进程更小的能独立运行的基本单位,可以脱离进程独立运行
B.引入线程可提高程序并发执行的程度,可进一步提高系统效率
C.线程的引入增加了程序执行时的时空开销
D.一个进程一定包含多个线程

**33.下面的叙述中,正确的是()**

A.同一进程内的线程可并发执行,不同进程的线程只能串行执行
B.同一进程内的线程只能串行执行,不同进程的线程可并发执行
C.同一进程或不同进程内的线程都只能串行执行
D.同一进程或不同进程内的线程都可以并发执行

**34.【2014统考真题】在支持多线程的系统中,进程P创建的若千线程不能共享的是()**

A.进程P的代码段
B.进程P中打开的文件
C.进程P的全局变量
D.进程P中某线程的栈针

**35.在以下描述中,()并不是多线程系统的特长**

A.利用线程并行地执行矩阵乘法运算
B.Web服务器利用线程响应HTTP请求
C.键盘驱动程序为每个正在运行的应用配备一个线程用以响应该应用的键盘输入
D.基于GUI的调试程序用不同的线程分别处理用户输入、计算和跟踪等操件

**36.【2012统考真题】下列关于进程和线程的叙述中,正确的是(**

A.不管系统是否支持线程,进程都是资源分配的基本单位
B.线程是资源分配的基本单位,进程是调度的基本单位
C.系统级线程和用户级线程的切换都需要内核的支持
D.同一进程中的各个线程拥有各自不同的地址空间

**37.在进程转换时,下列()转换是不可能发生的。**

A.就绪态→运行态
B.运行态→就绪态
C.运行态→阻塞态
D.阻塞态→运行态

**38.当()时,进程从执行状态转变为就绪态**

A.进程被调度程序选中
B.时间片到
C.等待某一事件
D.等待的事件发生

**39.两个合作进程( Cooperating Processes无法利用()交换数据**

A.文件系统
B.共享内存
C.高级语言程序设计中的全局变量
D.消息传递系统

**40.以下可能导致一个进程从运行态变为就绪态的事件是()**

A.一次I/O操作结束
B.运行进程需做I/O操作
C.运行进程结束
D.出现了比现在进程优先级更高的进程

答案：DBDDC ADBCD

**41.()必会引起进程切换**

A.一个进程创建后,进入就绪态
B.一个进程从运行态变为就绪态
C.一个进程从阻塞态变为就绪态
D.以上答案都不对

**42.进程处于()时,它处于非阻塞态**

A.等待从键盘输入数据
B.等待协作进程的一个信号
C.等待操作系统分配CPU时间
D.等待网络数据进入内存

**43.【2010统考真题】下列选项中,降低进程优先级的合理时机是()**

A.进程时间片用完
B.进程刚完成I/O操作,进入就绪队列
C.进程长期处于就绪队列
D.进程从就绪态转为运行态

**44.一个进程被唤醒,意味着()**

A.该进程可以重新竞争CPU
B.优先级变大
C.PCB移动到就绪队列之首
D.进程变为运行态

**45.进程创建时,不需要做的是()**

A.填写一个该进程的进程表项
B.分配该进程适当的内存
C.将该进程插入就绪队列
D.为该进程分配CPU

**46.计算机两个系统中两个协作进程之间不能用来进行进程间通信的是(）**

A.数据库
B.共享内存
C.消息传递机制
D.管道

**47.下列说法中,不正确的是()**

A.一个进程可以创建一个或多个线程
B.一个线程可以创建一个或多个线程
C.一个线程可以创建一个或多个进程
D.一个进程可以创建一个或多个进程

**48.【2014统考真题】一个进程的读磁盘操作完成后操作系统针对该进程必做的是()**

A.修改进程状态为就绪态
B.降低进程优先级
C.给进程分配用户内存空间
D.增加进程时间片大小

**49.【2014统考真题】下列关于管道(Pipe)通信的叙述中,正确的是()**

A.一个管道可实现双向数据传输
B.管道的容量仅受磁盘容量大小限制
C.进程对管道进行读操作和写操作都可能被阻塞
D.一个管道只能有一个读进程或一个写进程对其操作

**50.【2015统考真题】下列选项中,会导致进程从执行态变为就绪态的事件是()**

A.执行P(wait)操作
B.申请内存失败
C.启动I/O设备
D.被高优先级进程枪占

答案：BCAAD ACACD

**51.【2018统考真题】下列选项中,可能导致当前进程P租塞的事件是()**

Ⅰ.进程P申请临界资源
Ⅱ.进程P从磁盘读数据
Ⅲ.系统将CPU分配给高优先的进程

A.仅Ⅰ
B.仅Ⅱ
C.仅Ⅰ、Ⅱ
D.Ⅰ.Ⅱ.Ⅲ

**52.【2019统考真题】下列选项中,可能会将进程唤醒的事件是()**

Ⅰ.I/O结束
Ⅱ.某进程退出临界区
Ⅲ.当前进程的时间片用完

A.仅Ⅰ
B.仅Ⅲ
C.仅Ⅰ、Ⅱ
D.Ⅰ、Ⅱ、Ⅲ

53.【2019统考真题】下列关于线程的描述中,错误的是()

A.内核级线程的调度由操作系统完成
B.操作系统为每个用户级线程建立一个线程控制块
C.用户级线程间的切换比内核级线程间的切换效率高
D.用户级线程可以在不支持内核级线程的操作系统上实现

答案：CCB

#### 1.7.2、综合应用题

1.进程和程序之间可以形成一对一,一对多,多对一,多对多的关系请分别举例说明在什么情况下会形成这样的关系。

- 执行一条命令或运行一个应用程序时,进程和程序之间形成一对一的关系。进程在执行过程中可以加载执行不同的应用程序,从而形成一对多的关系;以不同的参数或数据多次执行同一个应用程序时,形成多对一的关系;并发地执行不同的应用程序时,形成多对多的关系

2.父进程创建子进程和主程序调用于程序有何不同?

- 父进程创建子进程后,父进程与子进程同时执行(并发)。主程序调用子程序后,主程序哲停在调用点,子程序开始执行,直到子程序返回,主程序才开始执行

3.为什么进程之间的通信必须借助于操作系统内核功能? 简单说明进程通信的几种主要方式

- 每个进程有自己独立的地址空间,在操作系统和硬件的地址保护机制下,进程无法访问其他进程的地址空间,所以必须借助于操作系统的系统调用函数实现进程之间的通信,进程通信的主要方式有
  - 1)共享内存区。通过系统调用创建共享内存区多个进程可以(通过系统调用)连接同个共享内存区,通过访问共享内存区实现进程之间的数据交换。使用共享内存区时需要利用信号量解决同步互斥问题。
  - 2)消息传递。通过发送/接收消息,系统调用实现进程之间的通信。当进程发送消息时,系统将消息从用户缓冲区复制到内核中的消息缓冲区,然后将消息缓冲区挂入消息队列。进程发送的消息保持在消息队列中,直到被另一进程接收,当进程接收消息时,系统从消息队列中解挂消息缓冲区,将消息从内核的消息缓冲区中复制到用户缓冲区,然后释放消息缓冲区。
  - 3)管道系统。管道是先进先出(FIFO)的信息流,允许多个进程向管道写入数据,允许多个进程从管道读出数据。在读/写过程中操作系统保证数据的写入顺序和读出顺序是一致的,进程通过读/写管道文件或管道设备实现彼此之间的通信
  - 4)共享文件。利用操作系统提供的文件共享功能实现进程之间的通信,这时,也需要信号量来解决文件共享操作中的同步和互斥问题。

4.什么是多线程?多线程与多任务有什么区别？

- 多线程是指在一个程序中可以定义多个线程井同时运行它们,每个线程可以执行不同的任务。
- 多线程与多任务的区别:多任务是针对操作系统而言的,代表操作系统可以同时执行的程序个数;多线程是针对一个程序而言的,代表一个程序可以同时执行的线程个数,而每个线程可以完成不同的任务

5.回答下列问题:

1)若系统中没有运行进程,是否一定没有就绪进程?为什么?

- 是。若系统中未运行进程,则系统很快会选择一个就绪进程运行。只有就绪队列中无进程时,CPU才可能处于空闲状态

2)若系统中既没有运行进程,又没有就绪进程,系统中是否就没有进程?为什么?

- 不一定,因为系统中的所有进程可能都处于等待态,可能处于死锁状态,也有可能因为等待的事件未发生而进入循环等特态

3)在采用优先级进程调度时，运行进程是否一定是系统中优先级最高的进程?

- 不一定。因为高优先级的进程有可能正处在等待队列中,进程调度会从就绪队列中选择一个进程占用CPU,这个被选中的进程可能优先级较低

6.现代操作系统一般都提供多进程(或称多任务)运行环境,回答以下问题:

1)为支持多进程的并发执行,系统必须建立哪些关于进程的数据结构?

- 为支持多进程的并发执行,系统为每个进程建立了一个数据结构:进程控制块(PCB),用于进程的管理和控制,PCB中记录了有关进程的一些描述信息和控制信息,包括进程标识符,进程当前的状态、优先级、进程放弃CPU时的现场信息,以及指示组成进程的程序和数据在存储器中存放位置的信息、资源使用信息、进程各种队列的连接指针和反映进程之间的隶属关系的信息等

2)为支持进程状态的变迁,系统至少应提供哪些进程控制原语?

- 在进程的整个生命周期中,会经历多种状态。进程控制的主要职能是对系统中所有进程实施有效的管理,它具有创建新进程、撤销已有进程、实现进程的状态转换等功能。在操作系统内核中,有一组程序专门用于完成对进程的控制,这些原语至少需要包括创建新进程原语、阻塞进程原语、唤醒进程原语、终止进程原语等操作。系统服务对用户开放,即用户可以通过相应的接口来使用它们。

3)执行每个进程控制原语时,进程状态发生什么变化?相应的数据结构发生什么变化?

- 进程创建原语:从PCB集合中申请一个空白的PCB,将调用者参数(如进程外部标识符、初始CPU状态、进程优先数、初始内存及申请资源清单等)添入该PCB,设置记账数据。置新进程为“就绪”态
- 终止进程原语:用于终止完成的进程,回收其所占资源。包括消去其资源描述块,消去进程的PCB
- 阻塞原语:将进程从运行态变为阻塞态。进程被插入等待事件的队列,同时修改PCB中相应的表项,如进程状态和等待队列指针等
- 唤醒原语:将进程从阻塞态变为就绪态。进程从阻塞队列中移出,插入就绪队列,等待调度,同时修改PCB中相应的表项,如进程状态等

7.某分时系统中的进程可能出现如下图所示的状态变化,请回答下列问题:

![os](http://images.zsjshao.net/ky/os/2/32.png)

1)图示,统用什么进程调度策?

- 根据题意,该系统采用的是时间片轮转法调度进程策略。

2)把图中每个状态变化的可能原因填写在下表中

![os](http://images.zsjshao.net/ky/os/2/33.png)

## 2、处理机调度

### 2.1、调度的概念

![os](http://images.zsjshao.net/ky/os/2/34.png)

#### 2.1.1、调度的基本概念

![os](http://images.zsjshao.net/ky/os/2/35.png)

在多道程序系统中,进程的数量往往多于处理机的个数因此进程争用处理机的情况在所难免处理机调度是对处理机进行分配,即从就绪队列中按照一定的算法(公平、高效)选择一个进程并将处理机分配给它运行,以实现进程并发地执行。

处理机调度是多道程序操作系统的基础,是操作系统设计的核心问题

#### 2.1.2、调度的层次

一个作业从提交开始直到完成,往往要经历以下三级调度,

![os](http://images.zsjshao.net/ky/os/2/36.png)

1)作业调度,又称高级调度,其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个(或多个)作业,给它(们)分配内存、输入/输出设备等必要的资源,并建立相应的进程,以使它(们)获得竞争处理机的权利。简言之,作业调度就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

多道批处理系统中大多配有作业调度,而其他系统中通常不需要配置作业调度,作业调度的执行频率较低,通常为几分钟一次。

![os](http://images.zsjshao.net/ky/os/2/37.png)

2)中级调度又称内存调度,其作用是提高内存利用率和系统吞吐量,为此,应将那些暂时不能运行的进程调至外存等待,把此时的进程状态称为挂起态。被挂起的进程PCB会被放到挂起队列中。当它们已具备运行条件且内存又稍有空闲时,由中级调度来决定把外存上的那些已具备运行条件的就绪进程,再重新调入内存,并修改其状态为就绪态,挂在就绪队列上等待。

![os](http://images.zsjshao.net/ky/os/2/38.png)

3)进程调度,又称低级调度,其主要任务是按照某种方法和策略从就绪队列中选取一个进程,将处理机分配给它。进程调度是操作系统中最基本的一种调度,在一般的操作系统中都必须配置进程调度。进程调度的频率很高,一般几十毫秒一次。

![os](http://images.zsjshao.net/ky/os/2/39.png)

补充知识：进程的挂起态与七状态模型

![os](http://images.zsjshao.net/ky/os/2/40.png)

#### 2.1.3、三级调度的联系

作业调度从外存的后备队列中选择一批作业进入内存,为它们建立进程,这些进程被送入就绪队列,进程调度从就绪队列中选出一个进程,并把其状态改为运行态,把CPU分配给它。中级调度是为了提高内存的利用率,系统将那些暂时不能运行的进程挂起来。当内存空间宽松时,通过中级调度选择具备运行条件的进程,将其唤醒。

- 1)作业调度为进程活动做准备,进程调度使进程正常活动起来,中级调度将暂时不能运行的进程挂起,中级调度处于作业调度和进程调度之间
- 2)作业调度次数少,中级调度次数略多,进程调度频率最高
- 3)进程调度是最基本的,不可或缺

![os](http://images.zsjshao.net/ky/os/2/41.png)

#### 2.1.4、总结

![os](http://images.zsjshao.net/ky/os/2/42.png)

### 2.2、调度的时机、切换与过程、方式

![os](http://images.zsjshao.net/ky/os/2/43.png)

#### 2.2.1、调度的时机

进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。

![os](http://images.zsjshao.net/ky/os/2/44.png)

进程调度和切换程序是操作系统内核程序。请求调度的事件发生后,才可能运行进程调度程序,调度了新的就绪进程后,才会进行进程间的切换。理论上这三件事情应该顺序执行,但在实际设计中,操作系统内核程序运行时,若某时发生了引起进程调度的因素,则不一定能够马上进行调度与切换。

现代操作系统中,不能进行进程的调度与切换的情况有以下几种:

- 1)在处理中断的过程中,中断处理过程复杂,在实现上很难做到进程切换,而且中断处理是系统工作的一部分,逻辑上不属于某一进程,不应被剥夺处理机资源。
- 2)进程在操作系统内核程序临界区中,进入临界区后,需要独占式地访问共享数据,理论上必须加锁,以防止其他并行程序进入,在解锁前不应切换到其他进程运行,以加快该共享数据的释放。
- 3)其他需要完全屏蔽中断的原子操作过程中,如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中,连中断都要屏蔽,更不应该进行进程调度与切换

若在上述过程中发生了引起调度的条件,则不能马上进行调度和切换,应置系统的请求调度标志,直到上述过程结束后才进行相应的调度与切换。

应该进行进程调度与切换的情况如下

- 1)发生引起调度条件且当前进程无法继续运行下去时,可以马上进行调度与切换。若操作系统只在这种情况下进行进程调度,则是非剥夺调度
- 2)中断处理结束或自陷处理结束后,返回被中断进程的用户态程序执行现场前,若置上请求调度标志,即可马上进行进程调度与切换。若操作系统支持这种情况下的运行调度程序,则实现了剥夺方式的调度

进程切换往往在调度完成后立刻发生,它要求保存原进程当前切换点的现场信息,恢复被调度进程的现场信息。现场切换时,操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们,并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后,开始运行新的进程。

#### 2.2.2、进程调度方式

所谓进程调度方式,是指当某个进程正在处理机上执行时,若有某个更为重要或紧迫的进程需要处理,即有优先权更高的进程进入就绪队列,此时应如何分配处理机。

![os](http://images.zsjshao.net/ky/os/2/45.png)

通常有以下两种进程调度方式:

1)非剥夺调度方式,又称非抢占方式。非剥夺调度方式是指当一个进程正在处理机上执行时,即使有某个更为重要或紧迫的进程进入就绪队列,仍然让正在执行的进程继续执行,直到该进程完成或发生某种事件而进入阻塞态时才把处理机分配给更为重要或紧迫的进程

在非剥夺调度方式下,一旦把CPU分配给一个进程,该进程就会保持CPU直到终止或转换到等待态。这种方式的优点是实现简单系统开销小,适用于大多数的批处理系统但它不能用于分时系统和大多数的实时系统。

2)剥夺调度方式,又称抢占方式。剥夺调度方式是指当一个进程正在处理机上执行时,若有某个更为重要或紧迫的进程需要使用处理机,则立即哲停正在执行的进程,将处理机分配给这个更为重要或紧迫的进程

采用剥夺式的调度,对提高系统吞吐率和响应效都有明显的好处。但“剥夺”不是一种任意性行为,必须遵循一定的原则,主要有优先权、短进程优先和时间片原则等。

#### 2.2.3、总结

进程切换的过程主要完成了：

- 1.对原来运行进程各种数据的保存

- 2.对新的进程各种数据的恢复

  （如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

![os](http://images.zsjshao.net/ky/os/2/46.png)

### 2.3、调度的基本准则（调度算法的评价指标）

![os](http://images.zsjshao.net/ky/os/2/47.png)

不同的调度算法具有不同的特性,在选择调度算法时,必须考虑算法的特性为了比较处理机调度算法的性能,人们提出了很多评价准则,下面介绍其中主要的几种：

#### 2.3.1、CPU利用率

CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU保持“忙”状态,使这一资源利用率最高。

- 利用率 = 忙碌的时间/总时间

#### 2.3.2、系统吞吐量

表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间,因此会降低系统的吞吐量。而对于短作业它们所需要消耗的处理机时间较短,因此能提高系统的吞吐量。调度算法和方式的不同,也会对系统的吞吐量产生较大的影响。

- 系统吞吐量 = 总共完成了多少道作业/总共花了多少时间

#### 2.3.3、周转时间

周转时间是指从作业提交到作业完成所经历的时间,是作业等待、在就绪队列中排队、在处理机上运行及进行输入/输出操作所花费时间的总和

- 作业的周转时间可用公式表示如下:
  -  周转时间=作业完成时间一作业提交时间

- 平均周转时间是指多个作业周转时间的平均值
  - 平均周转时间 = (作业1的周转时间++作业n的周转时间)/n

- 带权周转时间是指作业周转时间与作业实际运行时间的比值:
  - 带权周转时间=作业周转时间/作业实际运行时间

- 平均带权周转时间是指多个作业带权周转时间的平均值:
  - 平均带权周转时间 = (作业1的带权周转时间++作业n的带权周转时间)/n

#### 2.3.4、等待时间

等待时间指进程处于等处理机状态的时间之和,等待时间越长,用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间,只影响作业在就绪队列中等待所花的时间。因此,衡量一个调度算法的优劣,常常只需简单地考察等待时间

#### 2.3.5、响应时间

响应时间指从用户提交请求到系统首次产生响应所用的时间,在交互式系统中,周转时间不可能是最好的评价准则,一般采用响应时间作为衡量调度算法的重要准则之一。从用户角度来看,调度策略应尽量降低响应时间,使响应时间处在用户能接受的范围之内

要想得到一个满足所有用户和系统要求的算法几乎是不可能的。设计调度程序,一方面要满足特定系统用户的要求(如某些实时和交互进程的快速响应要求),另一方面要考虑系统整体效率(如减少整个系统的进程平均周转时间),同时还要考虑调度算法的开销

![os](http://images.zsjshao.net/ky/os/2/48.png)

### 2.4、典型的调度算法

调度算法的学习思路：

- 1.算法思想
- 2.算法规则
- 3.这种调度算法是用于作业调度还是进程调度？
- 4.抢占式？非抢占式？
- 5.优点和缺点
- 6.是否会导致饥饿（某进程/作业长期得不到服务）

操作系统中存在多种调度算法,有的调度算法适用于作业调度,有的调度算法适用于进程调度,有的调度算法两者都适用。下面介绍几种常用的调度算法。

#### 2.4.1、先来先服务(FCFS)调度算法

FCFS调度算法是一种最简单的调度算法,它既可用于作业调度,又可用于进程调度。在作业调度中,算法每次从后备作业队列中选择最先进入该队列的一个或几个作业,将它们调入内存,分配必要的资源,创建进程并放入就绪队列。

在进程调度中,FCFS调度算法每次从就绪队列中选择最先进入该队列的进程,将处理机分配给它,使之投入运行,直到完成或因某种原因而阻塞时才释放处理机。

![os](http://images.zsjshao.net/ky/os/2/49.png)

FCFS调度算法属于不可剥夺算法,从表面上看,它对所有作业都是公平的,但若一个长作业先到达系统,就会使后面的许多短作业等待很长时间,因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如,在使用优先级作为调度策略的系统中,往往对多个具有相同优先级的进程按FCFS原则处理

FCFS调度算法的特点是算法简单,但效率低对长作业比较有利,但对短作业不利(相对SJF和高响应比):有利于CPU繁忙型作业,而不利于I/O繁忙型作业。

![os](http://images.zsjshao.net/ky/os/2/50.png)

#### 2.4.2、短作业优先(SJF)调度算法

短作业(进程)优先调度算法是指对短作业(进程)优先调度的算法,短作业优先(SJF)调度算法从后备队列中选择一个或若干估计运行时间最短的作业,将它们调入内存运行；短进程优先(SJF)调度算法从就绪队列中选择一个估计运行时间最短的进程,将处理机分配给它,使之立即执行,直到完成或发生某事件而阻塞时,才释放处理机。

![os](http://images.zsjshao.net/ky/os/2/51.png)

![os](http://images.zsjshao.net/ky/os/2/52.png)

SJF调度算法也存在不容忽视的缺点:

- 1)该算法对长作业不利,由上三图可知,SJF调度算法中长作业的周转时间会增加。更严重的是,若有一长作业进入系统的后备队列,由于调度程序总是优先调度那些(即使是后进来的)短作业,将导长作业期不调度(“饥饿”现象，注意区分“死锁”后者是系统环形等待,前者是调度策略问题)
- 2)该算法完全未考虑作业的紧迫程度,因而不能保证紧迫性作业会被及时处理
- 3)由于作业的长短只是根据用户所提供的估计执行时间而定的,而用户又可能会有意或无意地缩短其作业的估计运行时间,致使该算法不一定能真正做到短作业优先调度

注意,SJF调度算法的平均等待时间、平均周转时间最少

![os](http://images.zsjshao.net/ky/os/2/53.png)

#### 2.4.3、高响应比优先调度算法

高响应比优先调度算法主要用于作业调度,是对FCFS调度算法和SJF调度算法的一种综合平衡,同时考虑了每个作业的等待时间和估计的运行时间。在每次进行作业调度时,先计算后备作业队列中每个作业的响应比,从中选出响应比最高的作业投入运行。

![os](http://images.zsjshao.net/ky/os/2/54.png)

响应比的变化规律可描述为

- 响应比Rp =（等待时间+要求服务时间）/ 要求服务时间

根据公式可知:

- 1)作业的等待时间相同时,要求服务时间越短响应比越高,有利于短作业。
- 2)要求服务时间相同时,作业的响应比由其等待时间决定,等待时间越长,其响应比越高,因而它实现的是先来先服务。
- 3)对于长作业,作业的响应比可以随等待时间的增加而提高,等待时间足够长时,其响应比便可升到很高,从而也可获得处理机。因此,克服了饥饿状态,兼顾了长作业。

![os](http://images.zsjshao.net/ky/os/2/55.png)

![os](http://images.zsjshao.net/ky/os/2/56.png)

#### 2.4.4、时间片轮转调度算法

时间片轮转调度算法主要适用于分时系统。在这种算法中,系统将所有就绪进程按到达时间的先后次序排成一个队列,进程调度程序总是选择就绪队列中的第一个进程执行,即先来先服务的原则,但仅能运行一个时间片,如100ms。在使用一个时间片后,即使进程并未完成其运行,它也必须释放出(被剥夺)处理机给下一个就绪的进程,而被剥夺的进程返回到就绪队列的末尾重新排队,等候再次运行

在时间片轮转调度算法中,时间片的大小对系统性能的影响很大,若时间片足够大,以至于所有进程都能在一个时间片内执行完毕,则时间片轮转调度算法就退化为先来先服务调度算法。若时间片很小,则处理机将在进程间过于频繁地切换,使处理机的开销增大,而真正用于运行用户进程的时间将减少。因此,时间片的大小应选择适当。

时间片的长短通常由以下因素确定:系统的响应时间、就绪队列中的进程数目和系统的处理能力。

![os](http://images.zsjshao.net/ky/os/2/57.png)

#### 2.4.5、优先调度算法

优先级调度算法又称优先权调度算法,它既可用于作业调度,又可用于进程调度。该算法中的优先级用于描述作业运行的紧迫程度。

在作业调度中,优先级调度算法每次从后备作业队列中选择优先级最高的一个或几个作业,将它们调入内存,分配必要的资源,创建进程并放入就绪队列。在进程调度中,优先级调度算法每次从就绪队列中选择优先级最高的进程,将处理机分配给它,使之投入运行。

根据新的更高优先级进程能否抢占正在执行的进程,可将该调度算法分为如下两种:

- 1)非剥夺式优先级调度算法。当一个进程正在处理机上运程时,即使有某个更为重要或紧迫的进程进入就绪队列,仍然让正在运行的进程继续运行,直到由于其自身的原因而主动让出处理机时(任务完成或等待事件),才把处理机分配给更为重要或紧迫的进程。
- 2)剥夺式优先级调度算法。当一个进程正在处理机上运行时,若有某个更为重要或紧迫的
  进程进入就绪队列,则立即暂停正在运行的进程,将处理机分配给更重要或紧迫的进程。

而根据进程创建后其优先级是否可以改变,可以将进程优先级分为以下两种:

- 1)静态优先级。优先级是在创建进程时确定的且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。
- 2)动态优先级。在进程运行过程中,根据进程情况的变化动态调整优先级。动态调整优先级的主要依据有进程占有CPU时间的长短、就绪进程等待CPU时间的长短。

一般来说,进程优先级的设置可以参照以下原则：

- 1)系统进程>用户进程。系统进程作为系统的管理者,理应拥有更高的优先级。
- 2)交互型进程>非交互型进程(或前台进程>后台进程)。大家平时在使用手机时,在前台运行的正在和你交互的进程应该更快速地响应你,因此自然需要被优先处理,即要有更高的优先级
- 3)I/O型进程>计算型进程。所谓I/O型进程,是指那些会频繁使用I/O设备的进程,而计算型进程是那些频繁使用CPU的进程(很少使用I/O设备)我们知道,I/O设备(如打印机)的处理速度要比CPU慢得多,因此若将I/O型进程的优先级设置得更高,就更有可能让I/O设备尽早开始工作,进而提升系统的整体效率。

![os](http://images.zsjshao.net/ky/os/2/58.png)

#### 2.4.6、多级反馈队列调度算法(融会了前几种算法的优点)

多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展,通过动态调整进程优先级和时间片大小,多级反馈队列调度算法可以兼顾多方面的系统目标。例如为提高系统吞吐量和缩短平均周转时间而照顾短进程:为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程;同时,也不必事先估计进程的执行时间。

多级反馈队列调度算法的实现思想如下：

- 1)设置多个就绪队列,并为各个队列赋予不同的优先级,第1级队列的优先级最高,第2级队列次之,其余队列的优先级逐次降低
- 2)赋予各个队列中进程执行时间片的大小各不相同。在优先级越高的队列中,每个进程的运行时间片越小。例如,第2级队列的时间片要比第1级队列的时间片长1倍------第i+1级队列的时间片要比第i级队列的时间片长1倍
- 3)一个新进程进入内存后,首先将它放入第1级队列的末尾,按FCFS原则排队等待调度。当轮到该进程执行时,如它能在该时间片内完成,便可准备撤离系统；若它在一个时间片结束时尚未完成,调度程序便将该进程转入第2级队列的末尾,再同样按FCFS原则等待调度执行；若它在第2级队列中运行一个时间片后仍未完成,再以同样的方法放入第3级队列如此下去,当一个长进程从第1级队列依次降到第n级队列后,在第n级队列中便采用时间片轮转的方式运行。
- 4)仅当第1级队列为空时,调度程序才调度第2级队列中的进程运行:仅当第1~(i-1)级队列均为空时,才会调度第i级队列中的进程运行。若处理机正在执行第i级队列中的某进程,这时又有新进程进入优先级较高的队列[第1~(i-1)中的任何一个队列],则此时新进程将抢占正在运行进程的处理机,即由调度程序把正在运行的进程放回第i级队列的末尾,把处理机分配给新到的更高优先级的进程。

多级反馈队列的优势有以下几点:

- 1)终端型作业用户:短作业优先。
- 2)短批处理作业用户:周转时间较短。
- 3)长批处理作业用户：经过前面几个队列得到部分执行,不会长期得不到处理

![os](http://images.zsjshao.net/ky/os/2/59.png)

![os](http://images.zsjshao.net/ky/os/2/60.png)

### 2.5、小结

1)为什么要进行处理机调度?

若没有处理机调度,同意味着要等到当前运行的进程执行完毕后,下一个进程才能执行而实际情况中,进程时常需要等待一些外部设备的输入，而外部设备的速度与处理机相比是非常缓慢的,若让处理机总是等待外部设备,则对处理机的资源是极大的浪费。而引进处理机调度后,可在运行进程等待外部设备时,把处理机调度给其他进程,从而提高处理机的利用率,用一句简单的话说,就是为了合理地处理计算机的软/硬件资源

2)调度算法有哪几种?结合第1章学习的分时操作系统和实时操作系统,思考有没有哪利调度算法比较适合这两种操作系统

本节介绍的调度算法有先来先服务调度算法、短作业优先调度算法、优先级调度算法、高响应比优先调度算法、时间片轮转调度算法、多级反馈队列调度算法6种。

先来先服务算法和短作业优先算法无法保证及时地接收和处理问题,因此无法保证在规定的时间间隔内响应每个用户的需求,也同样无法达到实时操作系统的及时性需求。优先级调度算法按照任务的优先级进行调度,对于更紧急的任务给予更高的优先级,适合实时操作系统

高响应比优先调度算法、时间片轮转调度算法、多级反馈队列调度算法都能保证每个任务在一定时间内分配到时间片,并轮流占用CPU,适合分时操作系统

本节主要介绍了处理机调度的概念。操作系统主要管理处理机、内存、文件、设备几种资源,只要对资源的请求大于资源本身的数量,就会涉及调度。例如,在单处理机系统中,处理机只有一个,而请求服务的进程却有多个,所以就有处理机调度的概念出现。而出现调度的概念后,又有了一个问题,即如何调度、应该满足谁、应该让谁等待,这是调度算法所回答的问题:而应该满足谁、应该让谁等待,要遵循一定的准则,即调度的准则。调度这一概念贯穿于操作系统的始终,读者在接下来的学习中,将接触到几种资源的调度问题和相应的调度算法,将它们与处理机调度的内容相对比,将会发现它们有异曲同工之妙

本节的知识架构图如下：

![os](http://images.zsjshao.net/ky/os/2/61.png)

### 2.6、习题

#### 2.6.1、单项选择题

**1.时间片轮转调度算法是为了()**

A.多个用户能及时干预系统
B.使系统变得高效
C.优先级较高的进程得到及时响应
D.需要CPU时间最少的进程最先做

**2.在单处理器的多进程系统中,进程什么时候占用处理器及决定占用时间的长短是由()决定的**

A.进程相应的代码长度
B.进程总共需要运行的时间
C.进程特点和进程调度策略
D.进程完成什么功能

**3.()有利于CPU繁忙型的作业,而不利于I/O繁忙型的作业**

A.时间片轮转调度算法
B.先来先服务调度算法
C.短作业(进程)优先算法
D.优先调度算法

**4.下面有关选择进程调度算法的准则中,不正确的是()**

A.尽快响应交互式用户的请求
B.尽量提高处理器利用率
C.尽可能提高系统吞量
D.适当增长进程就绪队列的等待时间

**5.设有4个作业同时到达,每个作业的执行时间均为2h,它们在一台处理器上按单道式运行,则平均周转时间为()**

 A.1h
 B.5h
 C.2.5h
 D.8h

答案：ACBDB

**6.若每个作业只能建立一个进程,为了照顾短作业用户,应采用();为了照顾紧急作业用户,应采用();为了能实现人机交互,应采用();而能使短作业长作业和交互作业用户都满意,应采用()**

A.FCFS调度算法
B.短作业优先调度算法
C.时间片轮转调度算法
D.多级反馈队列调度算法
E.剥夺式优先级调度算法

**7()优先级是在创建进程时确定的,确定之后在整个运行期间不再改变**

A.先来先服务
B.动态
C.短作业
D.静态

**8.现在有三个同时到达的作业J1,J2和J3,它们的执行时间分别是T1,T2,T3,且T1<T2<T3.系统按单道方式运行且采用短作业优先调度算法,则平均周转时间是()**

 A.T1+T2+T3
B.(3T1+2T2+T3)/3
C.(T1+T2+T3)/3
D.(1+2T2+3T3)/3

**9.设有三个作业,其运行时间分别是2h,5h,3h,假定它们同时到达,并在同一台处理器上以单道方式运行,则平均周转时间最小的执行顺序是()**

A.J1,J2,J3
B.J3,J2,J1
C.J2,J1,J3
D.J1,J3.J2

**10.【2013统考真题】某系统正在执行三个进程P1,P2和P3,各进程的计算(CPU)时间和I/O时间比例如下表所示**

| 进程 | 计算时间 | I/O时间 |
| ---- | -------- | ------- |
| P1   | 90%      | 10%     |
| P2   | 50%      | 50%     |
| P3   | 15%      | 85%     |

为提高系统资源利用率,合理的进程优先级设置应为()

A.P1>p2>P3
B.P3>P2>P1
C.P2>P1=P3
D.P1>P2=P3

答案：BECD DBDB

**11.采用时间片轮转调度算法分配CPU时,当处于运行态的进程用完一个时间片后,它的状态是()状态**

A.阻塞
B.运行
C.就绪
D.消亡

**12.一个作业8:00到达系统,估计运行时间为1h.若10:00开始执行该作业,其响应比是()**

A.2
B.1
C.3
D.0.5

**13关于优先权大小的论述中,正确的是()**

A.计算型作业的优先权,应高于I/O型作业的优先权
B.用户进程的优先权,应高于系统进程的优先权
C.在动态优先权中,随着作业等待时间的增加,其优先权将随之下降
D.在动态优先权中,随着进程执行时间的增加。其优先权降低

**14.下列调度算法中,()调度算法是绝对可抢占的**

A.先来先服务
B.时间片轮转
C.优先级
D.短进程优先

**15.作业是用户提交的,进程是由系统自动生成的,除此之外,两者的区别是()**

A.两者执行不同的程序段
B.前者以用户任务为单位,后者以操作系统控制为单位
C.前者是批处理的,后者是分时的
D.后者是可并发执行,前者则不同

答案：CCDBB

**16.【2009统考真题】下列进程调度算法中,综合考虑进等待时间和执行时间的是()**

A.时间片轮转调度算法
B.短进程优先调度算法
C.先来先服务调度算法
D.高响应比优先调度算法

**17.进程调度算法采用固定时间片轮转调度算法,当时间片过大时,就会使时间片轮转法算法转化为()调度算法**

A.高响应比优先
B.先来先服务
C.短进程优先
D以上选项都不对

**18.有以下的进程需要调度执行(见下表):**

| 进程名 | 到达时间 | 运行时间 |
| ------ | -------- | -------- |
| P1     | 0.0      | 9        |
| P2     | 0.4      | 4        |
| P3     | 1.0      | 1        |
| P4     | 5.5      | 4        |
| P5     | 7        | 2        |

1)若用非抢占式短进程优先调度算法,问这5个进程的平均周转时间是多少?

2)若采用抢占式短进程优先调度算法,问这5个进程的平均周转时间是多少?

A.8.62;6.34
B.8.62;6.8
C.10.62；6.34
D.10.62；6.8

**19.有5个批处理作业A,B,C,D,E几乎同时到达,其预计运行时间分别为10,6,2,4,8,其优先级(由外部设定)分别为3.5.2.1.4,这里5为最高优先级。以下各种调度算法中,平均周转时间为14的是()调度算法**

A.时间片轮转(时间片为1)
B.优先级调度
C.先来先服务(按照顺序10,6,2,4,8)
D短作业优先

**20.【2017统考真题】假设4个作业到达系统的时刻和运行时间如下表所示**

| 作业 | 到达时刻t | 运行时间 |
| ---- | --------- | -------- |
| J1   | 0         | 3        |
| J2   | 1         | 3        |
| J3   | 1         | 2        |
| J4   | 3         | 1        |

系统在t=2时开始作业调度。若分别采用先来先服务和短作业优先调度算法。则选中的作业分别是()
 A.J2,J3
 B. J1,J4
 C.J2,J4
 D.J1, J3

答案：DBDDD

**21.【2012统考真题】一个多道批处理系统中仅有P1和P2两个作业,P2比P1晚5ms到达,它的计算和I/O操作顺序如下:**

P1:计算60ms,I/O 80ms:计算20ms

P2:计算120ms,I/O 40ms计算40ms

若不考虑调度和切换时间,则完成两个作业需要的时间最少是()

 A.240ms
 B.260ms
 C.340ms
 D.360ms

**22.【2016统考真题】某单CPU系统中有输入和输出设备各1台,现有3个并发执行的作业,每个作业的输入,计算和输出时间均分别为2ms,3ms和4ms,且都按输入,计算和输出的顺序执行,则执行完3个作业需要的时间最少是()**

 A.15ms
 B.17ms
 C.22ms
 D.27ms

**23.【2017统考真题】下列有关基时间片的进程调度的叙述中,错误的是()**

A.时间片越短,进程切换的次数越多,系统开销越大
B.当前进程的时间片用完后,该进程状态由执行态变为阻塞态
C.时钟中断发生后,系统会修改当前进程在时间片内的剩余时间
D.影响时间片大小的主要因素包括响应时间、系统开销和进程数量等

**24.分时操作系统通常采用()调度算法来为用户服务**

A.时间片轮转
B.先来先服务
C.短作业优先
D.优先级

**25.在进程调度算法中,对短进程不利的是()**

A.短进程优先调度算法
B.先来先服务调度算法
C.高响应比优先调度算法
D.多级反馈队列调度算法

答案：BBBAB

**26.假设系统中所有进程同时到达,则使进程平均周转时间最短的是()调度算法。**

A.先来先服务
B.短进程优先
C.时间片轮转
D.优先级

**27.下列说法中,正确的是()**

Ⅰ.分时系统的时间片固定,因此用户数越多响应时间越长

Ⅱ.unix是一个强大的多用户、多任务操作系统,支持多种处理器构,按照操作系统分类,属于分时操作系统

Ⅲ,中断向量地址是中断服务例行程序的入口地址

Ⅳ.中断发生时,由硬件保护并更新程序计数器(PC),而不是由软件完成,主要是为了提高处理速度

A.Ⅰ.Ⅱ
B.Ⅱ.Ⅲ
C.Ⅲ.Ⅳ
D.仅Ⅳ

**28.【2012统考真题】若某单处理器多进程系统中有多个就绪态进程,则下列关于处理机调度的叙述中,错误的是()**

A.在进程结束时能进行处理机调度
B.创建新进程后能进行处理机调度
C.在进程处于临界区时不能进行处理机调度
D.在系统调用完成并返回用户态时能进行处理机调度

**29.【2011考真题】下列选项中,满足短作业优先且不会发生饥饿观象的是()调度算法**

A.先来先服务
B.高响应比优先
C.时间片轮转
D.非抢占式短作业优先

**30.【2014统考真题】下列调度算法中,不可能导致饥饿现象的是()**

A.时间片轮转
B.静态优先数调度
C.非抢占式短任务优先
D.抢占式短任务优先

答案：BACBA

**31.【2018统考真题】某系统采基于优先权的非抢占式进程调度策略,完成一次进程调度和进程切换的系统时间开销为1us.在T时刻就绪队列中有3个进程P1、P2和P3,其在就绪队列中的等待时间,需要的CPU时间和优先权如下表所示**

| 进程 | 等待时间 | 需要的CPU时间 | 优先权 |
| ---- | -------- | ------------- | ------ |
| P1   | 30us     | 12us          | 10     |
| P2   | 15us     | 24us          | 30     |
| P3   | 18us     | 36us          | 20     |

若优先权值大的进程优先获得CPU,从T时刻起系统开始进程调度,则系统的平均周转时间为()

 A. 54us
 B. 73us
 C.74us
 D.75us

**32.【2019统考真题】系统采用二级反馈队列调度算法进行进程调度,就绪队列Q1采用时间片轮转调度算法,时间片为10ms;就绪队列Q2采用短进程优先调度算法;系统优先调度Q1队列中的进程,当Q1为空时系统才会调度Q2中的进程;新创建的进程首先进入Q1;Q1中的进程执行一个时间片后,若未结束,则转入Q2.若当前Q1,Q2为空,系统依次创建进程P1,P2后即开始进程调度,P1,P2需要的CPU时间分别为30ms和20ms则进程P1,P2在系统中的平均等待时间为()**

 A.25ms
 B.20ms
 C.15ms
 D.10ms

答案：DC

#### 2.6.2、综合应用题

**1.为什么说多级反馈队列调度算法能较好地满足各类用户的需要?**

- 多级反馈队列调度算法能较好地满足各种类型用户的需要。对终端型作业用户而言,由于它们提交的作业大多属于交互型作业,作业通常比较短小,系统只要能使这些作业在第1级队列所规定的时间片内完成,便可使终端型作业用户感到满意；对于短批处理作业用户而言,它们的作业开始时像终端型作业一样,若仅在第1级队列中执行一个时间片即可完成,便可获得与终端型作业一样的响应时间,对于稍长的作业,通常也只需要在第2级队列和第3级队列中各执行一个时间片即可完成,其周转时间仍然较短;对于长批处理作业用户而言它们的长作业将依次在第1,2,...,n级队列中运行，然后再按时间片轮转方式运行,用户不必担心其作业长期得不到处理

**2.将一组进程分为4类如下图所示。各类进程之间采用优先级调度算法,而各类进程的内部采用时间片轮转调度算法,请简述P1,P2,P3,P4,P5,P6,P7,P8进程的调度过程**

![os](http://images.zsjshao.net/ky/os/2/62.png)

- 由题意可知,各类进程之间采用优先级调度算法,而同类进程内部采用时间片轮转调度算法因此,系统首先对优先级为4的进程P1,P2,P3采用时间片轮转调度算法运行;当P1,P2,P3均运行结束或没有可运行的进程(即P1,P2,P3都处于等待态;或其中部分进程已运行结束,其余进程处于等待态)时,对优先级为3的进程P4,P5采用时间片轮转调度算法运行。在此期间,若未结束的P1,P2,P3有一个转为就绪态,则当前时间片用完后又回到优先级4进行调度。类似地,当P1~P5均运行结束或没有可运行进程(即P1~P5都处于等待态;或其中部分进程已运行结束,其余进程处于等待态)时,对优先级为2的进程P6,P6,P8采用时间片轮转调度算法运行,一旦P1~P5中有一个转为就绪态,当前时间片用完后立即回到相应的优先级进行时间片轮转调度。

**3.设某计算机系统有一个CPU、一台输入设备、一台打印机。现有两个进程同时进入就绪态,且进程A先得到CPU运行,进程B后运行,进程A的运行轨迹为:计算50ms,打印信息100ms,再计算50ms,打印信息100ms,结束。进程B的行轨迹为:计算50ms,输入数据80ms,再计算100ms,结束。试画出它们的甘特图,并说明**

1)开始运行后,CPU有无空闲等待?若有,在哪段时内等待?计算CPU的利用率

2)进程A运行时有无等待现象?若有,在什么时候发生等待现象?

3)进程B运行时有无等待现象?若有,在什么时候发生等待现象?

![os](http://images.zsjshao.net/ky/os/2/64.png)

- 1)  有,在100~150ms等待,利用率=[300-(150-100)]/300×100%=83.3%
- 2)  无
- 3)  有,在0-50ms、180--200ms时发生等待现象。

**4.有一个CPU和两台外设D1,D2,且在能够实现抢占式优先级调度算法的多道程序环境中,同时进入优先级由高到低的P1,P2,P3三个作业,每个作业的处理顺序和使用资源的时间如下:**

 P1: D2 (30ms). CPU (10ms). D1 (30ms), CPU (10ms)
 P2: D1, (20ms), CPU (20ms). D2 (40ms)
 P3: CPU (30ms), D1. (20ms)

假设忽略不计其他辅助操作的时间,每个作业的周转时间T1，T2，T3分别为多少?CPU和D1的利用率各是多少?

![os](http://images.zsjshao.net/ky/os/2/65.png)

- 作业P1的优先级最高,周转时间等于运行时间,T1=80ms;作业P2的等特时间为10ms,运行时间为80ms,周转时间T2=(10+80)ms=90ms:作业P3的等待时间为40ms,运行时间为50ms,因此周转时间T3=90ms
- 三个作业从进入系统到全部运行结束,时间为90ms,CPU与外设都是独占设备,运行时间分别为各作业的使用时间之和。CPU运行时间为(10+10)+20+30]ms=70ms,D1为(30+20+20)ms=70ms,D2为(30+40)ms=70ms,因此利用率均为70/90=77.8%

**5.有三个作业A,B,C,它们分别单独运行时的CPU和I/O占用时间如下图所示**

![os](http://images.zsjshao.net/ky/os/2/63.png)

现在请考虑三个作业同时开始执行。系统中的资源有一个CPU和两台输入/输出设备(I/O1和I/O2)同时运行。三个作业的优先级为A最高、B次之、C最低,一旦低优先级的进程开始占用CPU，高优先级进程也要等待到其结束后方可占用CPU,请回答下面的问题:

1)最早结束的作业是哪个?

2)最后结束的作业是哪个?

3)计算这段时间CPU的利用率(三个作业全部结束为止)

![os](http://images.zsjshao.net/ky/os/2/66.png)

- 1)  最早结束的是作业B
- 2)  最后结束的是作业A
- 3)  三个作业从开始到全部执行结束,经历时间为210ms,由于是单CPU系统,CPU运行时间为各个作业的CPU运行时间之和,即[(20+10+20)+(40+30)+(40+20)ms=180ms.因此CPU的利用率为180/210=85.7%

**6.假定要在一台处理器上执行下表所示的作业,且假定这些作业在时刻0以1,2,3,4,5的顺序到达,说明分别使用FCFS、RR(时间片=1)、SJF及非剥夺式优先级调度算法时,这些作业的执行情况(优先级的高低顺序依次为1到5)。**

针对上述每种调度算法,给出平均周转时间和平均带权周转时间。

| 作业 | 执行时间 | 优先级 |
| ---- | -------- | ------ |
| 1    | 10       | 3      |
| 2    | 1        | 1      |
| 3    | 2        | 3      |
| 4    | 1        | 4      |
| 5    | 5        | 2      |

1)  作业执行情况可以用如下的甘特图来表示

![os](http://images.zsjshao.net/ky/os/2/67.png)

2)  各个作业对应于各个算法的周转时间和加权周转时间见下表。

![os](http://images.zsjshao.net/ky/os/2/68.png)

- 所以,FCFS的平均周转时间为13.4,平均加权周转时间为 7.26
- RR的平均周转时间为9.2,平均加权周转时间为2.84
- SJF的平均周转时间为7,平均加权周转时间为1.74
- 非剥夺式优先级调度算法的平均周转时间为12,平均加权周转时间为6.36
- 注意:SJF的平均周转时间肯定是最短的,计算完毕后可以利用这个性质进行检验

**7.有一个具有两道作业的批处理系统,作业调度采用短作业优先调度算法,进程调度采用抢占式优先级调度算法,作业的运行情况见下表,其中作业的优先数即进程的优先数,优先数越小,优先级越高**

| 作业 | 到达时间 | 运行时间 | 优先数 |
| ---- | -------- | -------- | ------ |
| 1    | 8:00     | 40分钟   | 5      |
| 2    | 8:20     | 30分钟   | 3      |
| 3    | 8:30     | 50分钟   | 4      |
| 4    | 8:50     | 20分钟   | 6      |

1)列出所有作业进入内存的时间及结束的时间(以分为单位)

2)计算平均周转时间

- 1)  具有两道作业的批处理系统,内存只存放两道作业,它们采用抢占式优先级调度算法竞争CPU,而将作业调入内存采用的是短作业优先调度.8:00,作业1到来,此时内存和处理机空闲,作业1进入内存并占用处理机:8:20,作业2到来,内存仍有一个位置空闲,因此将作业2调入内存,又由于作业2的优先数高,相应的进程抢占处理机,在此期间8:30作业3到来,但内存此时已无空闲,因此等待。直至8:50,作业2执行完毕,此时作业3、4竞争空出的一道内存空间,作业4的运行时间短,因此先调入,但它的优先数低于作业1,因此作业1先执行,到9:10时,作业1执行完毕,再将作业3调入内存,且由于作业3的优先数高而占用CPU,所有作业进入内存的时间及结束的时间见下表

![os](http://images.zsjshao.net/ky/os/2/69.png)

- 2)  平均周转时间为(70+30+90+90)/4=70min

**8.假设某计算机系统有4个进程，各进程的预计运行时间和到达就绪队列的时刻见下表(相对时间,单位为“时间配额”)。试用可抢占式短进程优先调度算法和时间片轮转调度算法进行调度(时间配额为2),分别计算各个进程的调度次序及平均周转时间**

| 进程 | 到达就绪队列时刻 | 预计运行时间 |
| ---- | ---------------- | ------------ |
| P1   | 0                | 8            |
| P2   | 1                | 4            |
| P3   | 2                | 9            |
| P4   | 3                | 5            |

1)  按照可抢先式短进程优先调度算法,进程运行时间见下表,

![os](http://images.zsjshao.net/ky/os/2/70.png)

- 时刻0.进程P到达并占用处理器运行
- 时刻1,进程P2到达,因其预计运行时间短,因此抢夺处理器进入运行,P1等待。
- 时刻2,进程P3到达,因其预计运行时间长于正在运行的进程,进入就绪队列等待
- 时刻3,进程P4到达,因其预计运行时间长于正在运行的进程,进入就绪队列等待
- 时刻5,进程P2运行结束,调度器在就绪队列中选择短进程,P4符合要求,进入运行,进程P1和进程P3则还在就绪队列等待
- 时刻10,进程P4运行结束,调度器在就绪队列中选择短进程,P1符合要求,再次进入运行,而进程P3则还在就绪队列等待
- 时刻17,进程P1运行结束,只剩下进程P3,调度其运行
- 时刻26,进程P3运行结束

2)  时间片轮转算法按就绪队列的FCFS进行轮转,在时刻2,P1被挂到就绪队列队尾,队列顺序为P2,P3,P1,此时P4还未到达,按时间片轮转算法的进程时间分配见下表

![os](http://images.zsjshao.net/ky/os/2/71.png)

- 平均周转时间=((22-0)+(12-1)+(26-2)+(23-3))4=19.25

**9.假设一个计算机系统具有如下性能特征:处理一次中断平均需要500us,一次进程调度平均需要花费1ms，进程的切换平均需要花费2ms,若该计算机系统的定时器每秒发出120次时钟中断,忽略其他I/O中断的影响,请问:**

1)操作系统将百分之几的CPU时间分配给时钟中断处理程序?

2)若系统采用时间片轮转调度算法,24个时钟中断为一个时间片,操作系统每进行一次进程的切换,需要花费百分之几的CPU时间?

3)根据上述结果,说明为了提高CPU的使用效率,可以采用什么对策

- 在时间片轮转调度算法中,系统将所有就绪进程按到达时间的先后次序排成一个队列进程调度程序总是选择队列中的第一个进程运行,且仅能运行一个时间片。在使用完一个时间片后,即使进程并未完成其运行,也必须将处理器交给下一个进程。时间片轮转调度算法是绝对可抢先的算法,由时钟中断来产生。
- 时间片的长短对计算机系统的影响很大若时间片大到让一个进程足以完成其全部工作,则这种算法就退化为先来先服务算法。若时间片很小,则处理器在进程之间的转换工作会过于频繁,处理器真正用于运行用户程序的时间将减少,系统开销将增大。时间片的大小应能使分时用户得到好的响应时间,同时也使系统具有较高的效率.
- 由题目给定条件可知:
  - 1)  每秒产生120个时钟中断,每次中断的时间为1/120≈8.3ms,其中中断处理耗时为500us,那么其开销为500us/83ms=6%
  - 2)  每次进程切换需要1次调度、1次切换,所以需要耗时1ms+2ms=3ms,每24个时钟为一个时间片,24×8.3≈200ms一次切换所cpu时间3ms/200ms=1.5%
  - 3)  为提高CPU的效率,一般情况下要尽量减少时钟中断的次数,如由每秒120次降低到100次,以延长中断的时间间隔或将每个时间片的中断数量(时钟数)加大,如由24个中断加大到36个。也可优化中断处理程序,减少中断处理开销,如将每次500us的时间降低到400us。若能这样,则时钟中断和进程切换的总开销占CPU的时间比为(36x400us+1ms+2ms)/(1/100×36)=4.8%

**10.【2016统考真题】某进程调度程序采用基于优先数( priority)的调度策略,即选择优先数最小的进程运行,进程创建时由用户指定一个nice作为静态优先数。为了动态调整优先数,引入运行时间 cpuTime和等待时间 waitTime,初值均为0.进程处于执行态时 cpuTime定时加1,且 waitTime置0;进程处于就绪态时, cpuTime置0, waitTime定时加1.请回答下列问题:**

1)若调度程序只将nice的值作为进程的优先数,即 priority = nice,则可能会出现饥饿现象。为什么?

2)使用nice, cpuTime和waitTime设计一种动态先数计算方法,以避免产生饥饿现象,并说明 waitTime的作用。

- 1)  由于采用了静志优先数,当就绪队列中总有优先数较小的进程时,优先数较大的进程一直没有机会运行,因而会出现饥饿现象。
- 1)  优先数 priority计算公式为 priority=nice+k1 x cpuTime - k2 x waitTime,其中k1>0,k2>0,用于分别调整 cpuTime和 waitTime在 priority所占的比例.waitTime可使长时间等待的进程优先数减少,从而避免出现饥饿现象。

**11.设有4个作业J1,J2,J3,J4,它们的到达时间和计算时间见下表,若这4个作业在一台处理器上按单道方式运行,采用高响应比优先调度算法，试写出各作业的执行顺序、各作业的周转时间及平均周转时间**

| 作业 | 到达时间 | 计算时间 |
| ---- | -------- | -------- |
| J1   | 8:00     | 2h       |
| J2   | 8:30     | 40min    |
| J3   | 9:00     | 25min    |
| J4   | 9:30     | 30min    |

作业的响应比可表示为

- 响应比=(等待时间+要求服务时间)/要求服务时间

在时刻8:00,系统中只有一个作业J1,因此系统将它投入运行。在J1完成(即10:00)时,J2,J3,J4的响应比分别为(90+40)/40,(60+5)25,(30+30)/30,即3.25,3.4,2,因此应先将J3投入运行。在完成(即10:25)时,J2,J4的响应比分别为(115+40)/40,(55+30)/30,即3.875,2.83因此应先将J2投入运行,待它运行完毕时(即11:05,再将J4投入运行,的结束时间为11:35.

可见作业的执行次序为J1,J3,J2,J4,各作业的运行情况见下表,它们的周转时间分别为120min,155min,85min.125min,平均周转时间为121.25min

![os](http://images.zsjshao.net/ky/os/2/72.png)

**12.在一个有两道作业的批处理系统中,有一作业序列,其到达时间及估计运行时间见下表。系统作业采用最高响应比优先调度算法[响应比=(等待时间+估计运行时间)/估计运行时间]。进程的调度采用短进程优先的抢占式调度算法**

| 作业 | 到达时间/min | 估计运行时间/min |
| ---- | ------------ | ---------------- |
| J1   | 10:00        | 35               |
| J2   | 10:10        | 30               |
| J3   | 10:15        | 45               |
| J4   | 10:20        | 20               |
| J5   | 10:30        | 30               |

1)列出各作业的执行时间(即列出每个作业运行的时间片段,如作业i的运行时间序列为10:00--10:40,11:00--11:20,11:30--11:50结束)。

2)计算这批作业的平均周转时间

上述5个作业的运行情况如下图所示

![os](http://images.zsjshao.net/ky/os/2/73.png)

在10:00,因为只有J1到达,因此将它调入内存,并将CPU调度给它

在10:10,J2到达,因此将J2调入内存,但由于J1需再执行25min,因此J1继续执行

虽然J3,J4,J5分别在10:15,10:20和10:30到达但因当时内存中已存放了两道作业,因此不能马上将它们调入内存

在10:35,J1结束.此时J3J4,J5的响应比[根据题意,响应比=(等待时间+估计运行时间)/估计运行时间]分别为65/45,35/20,35/30,因此将J4调入内存,并将CPU分配给内存中运行时间最短者,即J4

在10:55,J4结束。此时J3,J5的响应比分别为85/45,55/30,因此将J3调入内存,井将CPU分配给估计运行时间较短的J2

在11:25,J2结束,作业调度程序将J5调入内存,并将CPU分配给估计运行时间较短的J5

在11:55,J5结束,将CPU分配给J3

在12:40,J3结束。

通过上述分析,可知:

1)  作业1的执行时间片段为10:0010:35(结束)

- 作业2的执行时间片段为10:55—11:25(结束)
- 作业3的执行时间片段为11:55-12:40(结束)
- 作业4的执行时间片段为10:35-10:55(结束)
- 作业5的执行时间片段为11:25-11:55(结束)

2)  它们的周转时间分别为35min,75min,145min,35min,85min,因此它们的平均周转时间为75min.

## 3、进程同步

### 3.1、进程同步的进步概念

在多道程序环境下,进程是并发执行的,不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系,引入了进程同步的概念。

下面举一个简单的例子来帮大家理解这个概念。例如,让系统计算1+2x3,假设系统产生两个进程:一个是加法进程,一个是乘法进程要让计算结果是正确的,一定要让加法进程发生在乘法进程之后,但实际上操作系统具有异步性若不加以制约,加法进程发生在乘法进程之前是绝对有可能的,因此要制定一定的机制去约束加法进程,让它在乘法进程完成之后才发生,而这种机制就是本节要讨论的内容。

#### 3.1.1、临界资源

虽然多个进程可以共享系统中的各种资源,但其中许多资源一次只能为一个进程所用,我们将一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源,如打印机等。此外,还有许多变量、数据等都可以被若干进程共享,也属于临界资源。

对临界资源的访问,必须互斥地进行,在每个进程中,访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用,可把临界资源的访问过程分成4个部分:

- 1)  进入区。为了进入临界区使用临界资源,在进入区要检查可否进入临界区,若能进入临界区,则应设置正在访问临界区的标志,以阻止其他进程同时进入临界区
- 2)  临界区,进程中访问临界资源的那段代码,又称临界段。
- 3)  退出区。将正在访问临界区的标志清除。
- 4)  剩余区。代码中的其余部分。

![os](http://images.zsjshao.net/ky/os/2/74.png)

```
do {
  entry section;     //进入区
  critical section;  //临界区
  exit section;      //退出区
  remainder section; //剩余区
} while(true)
```

#### 3.1.2、同步

同步亦称直接制约关系,是指为完成某种任务而建立的两个或多个进程,这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系源于它们之间的相互合作。

例如,输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时,进程B不能获得所需数据而阻塞,一且进程A将数据送入缓冲区,进程B就被唤醒。反之,当缓冲区满时,进程A被阻塞,仅当进程B取走缓冲数据时,才唤醒进程A。

![os](http://images.zsjshao.net/ky/os/2/75.png)

#### 3.1.3、互斥

互斥也称间接制约关系。当一个进程进入临界区使用临界资源时,另一个进程必须等待,当占用临界资源的进程退出临界区后,另一进程才允许去访问此临界资源。

例如,在仅有一台打印机的系统中,有两个进程A和进程B,若进程A需要打印时,系统将打印机分配给进程B,则进程A必须阻塞,一进程B将打印机释放,系统便将进程A唤醒,并将其由阻塞态变为就绪态。

为禁止两个进程同时进入临界区,同步机制应遵循以下准则:

- 1)  空闲让进。临界区空时,可以允许一个请求进入临界区的进程立即进入临界区。
- 2)  忙则等待。当已有进程进入临界区时,其他试图进入临界区的进程必须等待。
- 3)  有限等待。对请求访问的进程,应保证能在有限时间内进入临界区。
- 4)  让权等待。当进程不能进入临界区时，应立即释放处理器,防止进程忙等待。

![os](http://images.zsjshao.net/ky/os/2/76.png)

### 3.2、实现临界区互斥的基本方法

#### 3.2.1、软件实现方法

在进入区设置并检查一些标志来标明是否有进程在临界区中,若已有进程在临界区,则在进入区通过循环检查进行等待,进程离开临界区后则在退出区修改标志

![os](http://images.zsjshao.net/ky/os/2/77.png)

##### 3.2.1.1、单标志法

该算法设置一个公用整型变量turn,用于指示被允许进入临界区的进程编号,即若turn=0,则允许P0进程进入临界区。该算法可确保每次只允许一个进程进入临界区,但两个进程必须交替进入临界区,若某个进程不再进入临界区,则另一个进程也将无法进入临界区(违背“**空闲让进**”)。这样很容易造成资源利用不充分。

若P顺利进入临界区并从临界区离开,则此时临界区是空的,但P1并没有进入临界区的打算,turn=1一直成立,P0就无法再次进入临界区(一直被while死循环困住）。

![os](http://images.zsjshao.net/ky/os/2/78.png)

##### 3.2.1.2、双标志先检查法

该算法的基本思想是在每个进程访问临界区资源之前,先查看临界资源是否正被访问,若正被访问,该进程需等待:否则,进程才进入自己的临界区。为此,设置一个数据flag[],如第0个元素值为 FALSE,表示P0进程未进入临界区,值为TRUE,表示P0进程进入临界区

![os](http://images.zsjshao.net/ky/os/2/79.png)

若按照①⑤②⑥...的顺序执行，P0和P1将会同时访问临界区。

因此，双标志先检查法的主要问题是：违反“忙则等待”的原则。

原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换

##### 3.2.1.3、双标志后检查法

双标志先检查法的改版，先将自己的标志设置为TRUE,再检测对方的状态标志,若对方标志为TURE,则进程等待:否则进入临界区

![os](http://images.zsjshao.net/ky/os/2/80.png)

若按照①⑤②⑥...的顺序执行，P0和P1将都无法进入临界区

因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生”饥饿“现象。

##### 3.2.1.4、Peterson算法

算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试”孔融让梨“，主动让对方先使用临界区。

![os](http://images.zsjshao.net/ky/os/2/81.png)

Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。

Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。

![os](http://images.zsjshao.net/ky/os/2/82.png)

#### 3.2.2、硬件实现方法

计算机提供了特殊的硬件指令,允许对一个字中的内容进行检测和修正,或对两个字的内容进行交换等,通过硬件支持实现临界段问题的方法称为低级方法,或称元方法。

![os](http://images.zsjshao.net/ky/os/2/83.png)

##### 3.2.2.1、中断屏蔽方法

当一个进程正在使用处理机执行它的临界区代码时,防止其他进程进入其临界区进行访问的最简方法是,禁止一切中断发生,或称之为屏蔽中断、关中断因为CPU只在发生中断时引起进程切换,因此屏蔽中断能够保证当前运行的进程让临界区代码顺利地执行完,进而保证互斥的正确实现,然后执行开中断。其典型模式为

![os](http://images.zsjshao.net/ky/os/2/84.png)

这种方法限制了处理机交替执行程序的能力,因此执行的效率会明显降低。对内核来说,在它执行更新变量或列表的几条指令期间,关中断是很方便的,但将关中断的权力交给用户则很不明智,若一个进程关中断后不再开中断,则系统可能会因此终止

##### 3.2.2.2、硬件指令方法

**TestAndSet指令**

- 简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令
- TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。

![os](http://images.zsjshao.net/ky/os/2/85.png)

若刚开始lock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。若刚开始lock是true，则执行TSL后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行”解锁“。

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境

缺点：不满足”让权等待“原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“。

**Swap指令**

有的地方也叫Exchange指令，或简称XCHG指令。

Swap指令是用硬件实现，执行的过程不允许被中断，只能一气呵成。

![os](http://images.zsjshao.net/ky/os/2/86.png)

逻辑上看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在old变量上），再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境

缺点：不满足”让权等待“原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“。

![os](http://images.zsjshao.net/ky/os/2/87.png)

### 3.3、信号量机制

信号量机制是一种功能较强的机制,可用来解决互斥与同步问题,它只能被两个标准的原语wait(S)和signal(S)访问,也可记为“P操作"和"V操作"

原语是指完成某种功能且不被分割、不被中执行的操作序列,通常可由硬件来实现。例如,前述的Test -and-Set和swap指令就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机上可由软件通过屏蔽中断方法实现。

原语之所以不能被中断执行,是因为原语对变量的操作过程若被打断,可能会去运行另一个对同一变量的操作过程,从而出现临界段问题。若能够找到一种解决临界段问题的元方法,就可以实现对共享变量操作的原子性

#### 3.3.1、整型信号量

整型信号量被定义为一个用于表示资源数目的整型量S

Eg：某计算机系统中有一台打印机...

![os](http://images.zsjshao.net/ky/os/2/88.png)

#### 3.3.2、记录型信号量

整型信号量的缺陷是存在”忙等“问题，因此人们又提出了”记录型信号量“，即用记录型数据结构表示的信号量。

![os](http://images.zsjshao.net/ky/os/2/89.png)

![os](http://images.zsjshao.net/ky/os/2/90.png)

#### 3.3.3、利用信号量实现进程同步

![os](http://images.zsjshao.net/ky/os/2/91.png)

#### 3.3.4、利用信号量实现进程互斥

![os](http://images.zsjshao.net/ky/os/2/92.png)

#### 3.3.5、利用信号量实现前驱关系

![os](http://images.zsjshao.net/ky/os/2/93.png)

![os](http://images.zsjshao.net/ky/os/2/94.png)

#### 3.3.6、生产者消费者问题

问题描述:一组生产者进程和一组消费者进程共享一个初始为空大小为n的缓冲区,只有缓冲区没满时,生产者才能把消息放入缓冲区,否则必须等待具有缓冲区不空时,消费者才能从中取出消息,否则必须等待,由于缓冲区是临界资源,它只允许一个生产者放入消息,或一个消费者从中取出消息

问题分析:

- 1)关系分析。生产者和消费者对缓冲区互斥访问是互斥关系,同时生产者和消费者又是一个相互协作的关系,只有生产者生产之后,消费者才能消费,它们也是同步关系。
- 2)整理思路这里比较简单,只有生产者和消费者两个进程,正好是这两个进程存在着互斥关系和同步关系,那么需要解决的是互斥和同步PV操作的位置。
- 3)信号量设置,信号量 mutex作为互斥信号量,用于控制互斥访问缓冲池,互斥信号量初值为1:信号量full用于记录当前缓冲池中的“满”缓冲区数,初值为0.信号量empty用于记录当前缓冲池中的“空”缓冲区数,初值为n

![os](http://images.zsjshao.net/ky/os/2/95.png)

思考：能否改变相邻P、V操作的顺序？

![os](http://images.zsjshao.net/ky/os/2/96.png)

不行，会产生死锁。实现互斥的P操作一定要在实现同步的P操作之后。

V操作不会导致进程阻塞，因此两个V操作顺序可以交换

根据对同步互斥问题的简单总结,我们发现,其实生产者消费者问题只是一个同步互斥问题的综合而已

![os](http://images.zsjshao.net/ky/os/2/97.png)

#### 3.3.7、多生产者-多消费者

问题描述:桌子上有一个盘子,每次只能向其中放入一个水果爸爸专向盘子中放苹果,妈妈专向盘子中放橘子,儿子专等吃盘子中的橘子,女儿专等吃盘子中的苹果。只有盘子为空时,爸爸或妈妈才可向盘子中放一个水果;仅当盘子中有自己需要的水果时,儿子或女儿可以从盘子中取出。

![os](http://images.zsjshao.net/ky/os/2/98.png)

![os](http://images.zsjshao.net/ky/os/2/99.png)

![os](http://images.zsjshao.net/ky/os/2/100.png)

#### 3.3.8、吸烟者问题

问题描述:假设一个系统有三个抽烟者进程一个供应者进程。每个抽烟者不停地卷烟并抽掉它,但要卷起并抽掉一支烟,抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟中,第一个拥有烟草,第二个拥有纸,第三个拥有胶水,供应者进程无限地提供三种材料,供应者每次将两种材料放到桌子上,拥有剩下那种材料的抽烟者卷一根烟并抽掉它,并给供应者一个信号告诉已完成,此时供应者就会将另外两种材料放到桌上,如此重复(让三个抽烟者轮流地抽烟)

![os](http://images.zsjshao.net/ky/os/2/101.png)

![os](http://images.zsjshao.net/ky/os/2/102.png)

若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各种V操作应该放在各自对应的”事件“发生之后的位置。

#### 3.3.9、读者-写者问题

问题描述:有读者和写者两组并发进程,共享一个文件,当两个或以上的读进程同时访问共享数据时不会产生副作用,但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时可能导致数据不一致的错误。因此要求:①允许多个读者可以同时对文件执行读操作;②只允许一个写者往文件中写信息:③任一写者在完成写操作之前不允许其他读者或写者工作;④写者执行写操作前,应让已有的读者和写者全部退出。

![os](http://images.zsjshao.net/ky/os/2/103.png)

#### 3.3.10、哲学家进餐问题

问题描述:一张圆桌边上坐着5名哲学家,每两名哲学家之间的桌上摆一根筷子,两根筷子中间是一碗米饭,如图2.10所示学家们倾注毕生精力用于思考和进餐,哲学家在思考时,并不影响他人,只有当哲学家饥饿时,才试图拿起左右两根筷子(一根根地拿起)。若筷子已在他人手上,则需要等待饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐,进餐完毕后,放下筷子继续思考

![os](http://images.zsjshao.net/ky/os/2/104.png)

当一名哲学家左右两边的筷子都可用时,才允许他抓起筷子。

```
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex = 1;
Pi (){
  while(1){
    P(mutex);
    P(chopstick[i]);
    P(chopstick[(i+1)%5]);
    V(mutex);
    eat...
    V(chopstick[i]);
    V(chopstick[(i+1)%5]);
    think...
  }
}
```

哲学家进餐问题的关键在于解决进程死锁。

多个临界资源问题。

### 3.4、管程

在信号量机制中,每个要访问临界资源的进程都必须自备同步的PV操作,大量分散的同步操作给系统管理带来了麻烦,且容易因同步操作不当而导致系统死镜。于是,便产生了一种新的进程同步工管程管程的特性保证了进程互斥,无须程序员自己实现互斥,从而降低了死锁发生的可能性。同时管程提供了条件变量,可以让程序员灵活地实现进程同步。

#### 3.4.1、管程的定义

系统中的各种硬件资源和软件资源,均可用数据结构抽象地描述其资源特性,即用少量信息和对资源所执行的操作来表征该资源,而忽略它们的内部结构和实现细节。

利用共享数据结构抽象地表示系统中的共享资源,而把对该数据结构实施的操作定义为一组过程进程对共享资源的申请、释放等操作,都通过这组过程来实现,这组过程还可以根据资源情况,或接受或阻塞进程的访问,确保每次仅有一个进程使用共享资源,这样就可以统一管理对共享资源的所有访问,实现进程互斥。这个代表共享资源的数据结构,以由对该共享数据结构实施操作的一组过程所组成的资源管理程序,称为管程( monitor)。管程定义了一个数据结构和能为井发进程所执行(在该数据结构上)的一组操作,这组操作能同步进程和改变管程中的数据

由上述定义可知,管程由4部分组成:

- ①管程的名称
- ②局部于管程内部的共享结构数据说明:
- ③对该数据结构进行操作的一组过程(或函数)
- ④对局于管程内部的共享数据设置初始值的语句

![os](http://images.zsjshao.net/ky/os/2/105.png)

引入管程的目的无非就是要更方便地实现进程互斥和同步

#### 3.4.2、条件变量

当一个进程进入管程后被阻塞,直到阻塞的原因解除时,在此期间,如果该进程不释放管程,那么其他进程无法进入管程,为此,将阻塞原因定义为条件变量 condition通常,一个进程被阻塞的原因可以有多个,因此在管程中设置了多个条件变量。每个条件变量保存了一个等待队列,用于记录因该条件变量而阻塞的所有进程,对条件变量只能进行两种操作,即wait和 signal

x.wait:当x对应的条件不满足时,正在调用管程的进程调用x,wait将自己插入x条件的等待队列,并释放管程。此时其他进程可以使用该管程

x.signal:x对应的条件发生了变化,则调用x.signal,唤醒一个因x条件而阻塞的进程

条件变量和信号量的比较:

- 相似点:条件变量的 wait/signal操作类似于信号量的PV操作,可以实现进程的阻塞/唤醒
- 不同点:条件变量是“没有值”的,仅实现了“排队等待”功能;而信号量是“有值”的,信号量的值反映了剩余资源数,而在管程中,剩余资源数用共享数据结构记录

![os](http://images.zsjshao.net/ky/os/2/106.png)

### 3.5、小结

1)为什么要引入进程同步的概念?

- 在多道程序共同执行的条件下,进程与进程是并发执行的,不同进程之间存在不同的相互制约关系。为了协调进程之间的相互制约关系,引入了进程同步的概念

2)不同的进程之间会存在什么关系?

- 进程之间存在同步与互斥的制约关系
- 同步是指为完成某种任务而建立的两个或多个进程,这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。
- 互斥是指当一个进程进入临界区使用临界资源时,另一个进程必须等待,当占用临界资源的进程退出临界区后,另一进程才允许去访问此临界资源

3)当单纯用本节介绍的方法解决这些问题时会遇到什么新的问题吗?

- 当两个或两个以上的进程在执行过程中,因占有一些资源而又需要对方的资源时,会因为争夺资源而造成一种互相等待的现象,若无外力作用,它们都将无法推进下去。这种现象称为死锁,具体介绍和解决方案请参考下一节

本节的知识架构图如下:

![os](http://images.zsjshao.net/ky/os/2/107.png)

### 3.6、习题

#### 3.6.1、单项选择题

**1.下列对临界区的论述中,正确的是()**

A.临界区是指进程中用于实现进程互斥的那段代码

B.临界区是指进程中用干实现进程同步的那段代码

C.临界区是指进程中用于实现进程通信的那段代码

D.临界区是指进程中用于访问临界资源的那段代码

**2.不需要信号量就能实现的功能是()**

A.进程同步
B.进程互斥
C.执行的前驱关系
D.进程的并发执行

**3.若一个信号量的初值为3,经过多次PV操作后当前值为-1,这表示等待进入临界区的进程数是()**

A.1
B.2
C.3
D.4

**4.【2010统考真题】设与某资源关联的信号量初值为3,当前值为1.若M表示该资源的可用个数,N表示等待该资源的进程数,则M,N分别是()**

A.0.1
B.1.0
C.1.2
D.2.0

**5.一个正在访问临界资源的进程由于申请等待I/O操作而被中断时,它()**

A.允许其他进程进入与该进程相关的临界区
B.不允许其他进程进入任何临界区
C.允许其他进程抢占处理器,但不得进入该进程的临界区
D.不允许任何程抢占处理器

答案：DDABC

**6.两个旅行社甲和乙为旅客到某航空公司订飞机票,形成互斥资源的是()**

A.旅行社
B.航空公司
C.飞机票
D.旅行社与航空公司

**7.临界区是描发进程访问共享变量段的()**

A.管理信息
B.信息存
C.数据
D.代码程序

**8.以下不是同步机制应遵循的准则的是()**

A.让权等待
B.空闲让进
C.忙则等待
**D.无限等待**

**9.以下()不属于临界资源**

A.打印机
**B.非共享数**
C.共享变量
D.共享缓冲区

10.以下()属于临界资源

A.磁盘存储介质
B.公用队列
C.私用数据
D.可重入的程序代码

答案：CDDBB

11.在操作系统中,要对并发进程进行同步的原因是()

A.进程必须在有限的时间内完成
B.进程具有动态性
C.并发进程是异步的
D.进程具有结构性

12.进程A和进程B通过共享缓冲区协作完成数据处理,进程A负责产生数据并放入缓冲区,进程B从缓冲区读数据并输出,进程A和进程B之间的制约关系是()

A.互斥关系
B.同步关系
C.互斥和同步关系
D无制约关系

13.在操作系统中,P,V操作是一种()

A.机器指令
B.系统调用命令
C.作业控制命令
D.低级进程通信原语

14.P操作可能导致()

A.进程就绪
B.进程结束
C.进程塞
D.新进程创建

15.原语是()

A.运行在用户态的过程
B.操作系统的内核
C.可中断的指令序列
D.不可分割的指令序列

16.()定义了共享数据结构和各种进程在该数据结构上的全部操作

A.管程
B.类程
C.线程
D.程序

17.用V操作唤醒一个等待进程时,被唤醒进程变为()

A.运行
B.等待
C.就绪
D.完成

18.在用信号量机制实现互时,互信号量的初值为()

A.0
B.1
C.2
D.3

19.用V操作实现进程同步,信号量的初值为(

A.-1
B.0
C.1
D.由用户确定

20.可以被多个进程在任意时刻共享的代码必须是()

A.顺序代码
B.机器语言代码
C.不允许任何修改的代码
D.无转移指令代码

21.一个进程映像由程序、数据及PCB组成,其中()必须用可重入编码编写

A.PCB
B.程序
C.数据
D.共享程序段

22.周来实现进程同步与互斥的PV操作实际上是由()过程组成的

A.一个可被中的
B.一个不可被中断的
C.两个可被中断的
D.两个不可被中断的

23.有三个进程共享同一程序段,而每次只允许两个进程进入该程序段,若用PV操作同步机制,则信号量S的取值范围是()

A.2,1,0,-1
B.3.2,10
C.2.10.-1.-2
D.1,0,-1,-2

24.对于两个并发进程,设互后信号量为 mutex(初值为1),若 mutex=0,则()

A.表示没有进程进入临界区
B.表示有一个进程进入临界区
C.表示有一个进程进入临界区,另一个进程等待进入
D.表示言两个进程进入界区

25.对于两个并发进程,设互信号量为mutex(初值为1),若 mutex-1,则()
A.表示没有进程进入临界区
国回
B.表示有一个进程进入临界区
C.表示有一个进程进入临界区,另一个进程等待进入
D.表示有两个进程进入临界区
26.一个进程在互斥信号量上执行mutex)操作而导致唤醒另一个进程时,执行V
操作后 mutex的值为()
A.大于0
B.小于0
C.大于等于0
D.小于等于0
27.若一个系统中共有5个并发进程涉及某个相同的变量A,则变量A的相关临界区是由()
个临界区构成的
A.1
B.3
C.5
28.下述()选项不是管程的组成部分
A.局限于管程的共享数据结构
B.对管程内数据结构进行操作的一组过程
C.管程外过程调用管程内数据结构的说明
D.对局限于管程的数据结构设置初始值的语句
29.以下关于管程的叙述中,错误的是()
A.管程是进程同步工具,解决信号量机制大量同步操作分散的问题
B.管程每次只允许一个进程进入管程
C.管程中 signal操作的作用和信号量机制中的V操作相同
D.管程是被进程调用的,管程是语法范围,无法创建和撤销
30.【2016统考真题】下列关于管程的叙述中,错误的是()
A.管程只能用于实现进程的互
B.管程是由编程语言支持的进程同步机制
C.任何时候只能有一个进程在管程中执行
D.管程中定义的变量只能被管程内的过程访问
31.对信号量S执行P操作后,使该进程进入资源等待队列的条件是()
 A.S.
 B. S.value=
 C. S.value>0
 D. S.value>-0
32.若系统有四个进程,则就队列中进程的个数最多有(①)个阻塞队列中进程的个
数最多有6②)个
①A,n+1B.nC.n-1D.1
②A.n+1B.nC.n-1
D.1
33.下列关于PV操作的说法中,正确的是()
LPV操作是一种系统调用命令
Ⅱ.PV操作是一种低级进程通信原语
ⅢPV操作是由一个不可被中断的过程组成
IV.PV操作是由两个不可被中断的过程组成
A..m
 B.. Iv

D.I.Ⅳ
34.下列关于临界区和临界资源的说法中,正确的是()
1.银行家算法可以用来解决临界区( Critical Section)问题
临界区是指进程中用于实现进程互斥的那段代码
Ⅲ公用队列属于临界资源
V.私用数据属于临界源
A.1.Ⅱ
B.1.
C.仅Ⅲ
D.以上答案都错误
35.有一个计数信号量S
1)假如若干进程对S进行28次P操作和18次V操作后,信号量S的值为0
2)假如若千进程对信号量S进行了15次P操作和2次操作请问此时有多少个进
程等待在信号量S的队列中?()
A.2
C.5
36.有两个并发进程P1和P2,其程序代码如下
P10
P2(
=1
/A1
y-2
!
 print
 print 2://A2
可能打印出的值有(),可能打印出的c值有()(其中x为P1,P2的共享变量)
A.z=1.-3;c=-1,9
B.z--1.3;c-19
C.z=-13,1;c=9
D.z=3:c=19
37.【2010统考真题】进程Po和进程P1的共享变量定义及其初值为:
 hoolean flag(
 int turn-0;
 flag10]=falae: flag[]=falae:
 yold进程0界资源的类
实现如下:
vodp1//进程p
 whilo(truo)
 while(true)
 flag []-true: turn-1:
 f1ag [11-trueturn-D
 while([1]&(=1))
 whilo(flag[0]&(turn==0))
临界区
临界区
fag0--falne
 riag111-talne:
》
则并发执行进程P和进程P1时产生的情况是()
A.不能保证进程互斥进入临界区,会出现“饥饿现象
B.不能保证进程互斥进入临界区,不会出现“饥饿”现象
C.能保证进程互斥进入临界区,会出现“饥饿”现象
D.他保进入修界,不会出“饿

38.【2016统考真题】进程P1和P2均包含并发执行的线程部分伪代码描述如下所示。

```
//进程P1                         //进程P2
  int x=0；                        int x=0；
  Thread1()                        Thread3()
  { int a;                         { int a;
    a=1; x+=1;                       a=x; x+=3;
  }                                }
  Thread2()                        Thread4()
  { int a;                         { int b;
    a=2; x+=2;                       b=x; x+=4;
  }                                }
```

下列选项中,需要互斥执行的操作是()
A.a=1与a=2
B.ax与
C.x+=1与x+=2
D.x+=1与x+=3

39.【2011统考真题】有两个并发执行的进程P1和进程P2共享初值为1的变量P1对x
加1,P2对减1,加1和减1操作的指序列分别如下
/加1操作
诚操作
 toad R11//取×到寄存器R
adR2//取x到寄存器R2
 inc R1
 7dec2
 storer1//将的内容存入 storer2//将r2的内容存入
两个操作完成后,x的值()
A.可能为-1或3
B.只能为1
C.可能为0.1或2
D.可能为-10.1或2
40.【2016统考真题】使用TSL(Test and Set Lock)描令实现进程互斥的伪代码如下所示
 dol
 while(TSL(])D
 critical section
 lock-FALSET
 while (TRUE)
下列与该实现机制相关的叙述中,正确的是()
A.退出临界区的进程负责唤醒塞态进程
B.等待进入临界区的进程不会主动放弃CPU
C.上述仿代码满足“让权等待”的同步准则
D. whileTSL&lock)语句应在关中断状态下执行
41.并发进程之间的关系是()
回
A.无关的
B.相关的
C.可能相关的
D.可能是无关的,也可能是有交往的
42.若有4个进程共享同一程序段,每次允许3个进程进入该程序段若用V
操作作为同步机制,则信号量的取值范围是()
A.4,3,2,1,-1
B.2,1,0.-1,-2

C.3,2,1,0,-1
D.2.1.0.-2,-3
43.在9个生产者,6个消费者共享容量为8的缓冲器的生产者消费者问题中,互使用缓
冲器的信号量初始值为()
A.1
B.6
C.8
D.9
44.信箱通信是一种()通信方式
A.直接通信
B.接通信
C.低级通信
D.信号量
45.有两个优先级相同的并发程序P1和P2,它们的执行过程如下所示,假设当前信号量s
0,s20.当前的=2,进程运行结束后xy和乙的值分别是(
进程P1
进程P2
y=1
x:-1
y:-y+2
x:=x+1
y+1
P(1
(81
 x:=x+y
P(2)
2:一
 y:=+y:
(s2)
A.5,9,9
C.5.12,9
D.5.12.4
46.【2018统考真题】属于同一进程的两个线程和 thread2并发执行,共享初值为0
的全局变量x threadl和 thread22实现对全局变量x加1的机器级代码描述如下

```
thread1                             | thread2
mov R1,x  //(x)->R1                 | mov R2,x  //(x)->R2
inc R1    //(R1)+1->R1              | inc R2    //(R2)+1->R2
mov x,R1  //(R1)->x                 | mov x,R2  //(R2)->x
```

在所有可能的指令执行序列中,使x的值为2的序列个数是()
A.1
B.2
C.3
D.4

47.【2018统考真题】若x是管程内的条件变量,则当进程执行 wait时所做的工作是()
A.实现对变量x的互斥访问
B.唤醒一个在上塞的进程
C.根据x的值判断该进程是否进入阻塞态
D.阻塞该进程,并将之插入的阻塞队列中
48.【2018考真题】在下列同步机制中,可以实现让权等待的是()
A. Peterson方法
B.swap指今
C.信号量方法
D. TestAndSet今

#### 3.6.2、综合应用题

1,何谓管程?管程由几部分组成?说明引入管程的必要性



2.进程之间存在哪几种制约关系?各是什么原因引起的?以下活动各属于哪种制约关系?
1)若干学生去图书馆借书
2)两队进行篮球比赛
3)流水线生产的各道工序
4)商品生产和消费

3.【2009统考真题】三个进程P1,P2,P3互斥使用一个包含N(N>0)个单元的缓冲区P
每次用 produce生成一个正整数并用put送入缓冲区某一空单元P2每次用 getoddo
该缓冲区中取出一个奇数并用 countodd计奇数个数;P3每次用 geteven从该缓冲区中
取出一个偶数并用 counteven)统计偶数个数请用信号量机制实现这三个进程的同步与
互斥活动,并说明所定义的信号量的含义(要求用伪代码描迷)

4.下面是两个并发执行的进程,它们能正确运行吗?若不能请举例说明并改正

```

```

5.有两个并发进程P1,P2,其程序代码如下:

```

```

1)可能打印出的值有多少?(假设每条赋值语句是一个原子操作)
2)可能打印出的c值有多少?(其中x为P1和P2的共享变量)

6在一个仓库中可以存放A和B两种产品,要求:
①每次只能存入一种产品
A产品数量-B产品数量<M.
③B产品数量A产品数量<N
其中,M,N是正整数,试用P操作、V操作描述产品A与产品B的入库过程
7.面包师有很多面包,由n名铺售人员推销每名顾客进店后取一个号,并且等待叫号,
当一名销售人员空闲时,就叫下一个号。试设计一个使销售人员和顾客同步的算法
8.【2013统考真题】某博物馆最多可容纳50人同时参观,有一个出入口,该出入口一次
仅允许一人通过。参观者的活动描述如下:

```

```

请添加必要的信号量和P,V或 wait, signalo操作,以实现上述过程中的互斥与同步要求写出完整的过程,说明信号量的含义并赋初值

9.某工厂有两个生产车间和一个装配车间,两个生产车间分别生产A,B两种零件,装配车
间的任务是把AB两种零件组装成产品,两个生产车间每生产一个零件后,都要分别把
它们送到专配车间的货架F1,F2上F1存放零件A,F2存放零件B,F1和F2的容量均可存放10个零件。装配工人每次从货架上取一个零件A和一个零件B后组装成产品请
用PV操作进行正确管理

10.某寺庙有小和尚,老和尚若干,有一水缸由小和尚提水入缸供老和尚饮用水缸可容
10桶水,水取自同一井中水井径窄,每次只能容一个桶取水水桶总数为3个,每次
入缸取水仅为1桶水,且不可同时进行,试给出有关从缸取水、入水的算法描述

11.如下图所示,三个合作进程P,P2P3,它们都需要通过同一设备输入各自的数据a,bc
该输入设备必须互斥地使用,而且其第一个数据必须山P进程读取,第二个数据必须由
P2进程读取,第三个数据必须由P进程读取,然后,三个进程分别对输入数据进行下列
计算:

:: x-a+
: y-a+b
 P: z-y+e-a
最后,P1进程通过所连接的打印机将计算结果xy的值打印出来请用信号量实现它
们的同步
12.【2011统考真题】某银行提供1个服务窗口和10个供顾客等待的座位,顾客到达银行
时,若有空座位,则到取号机上领取一个号等待叫号取号机每次仅允许一位顾客使
用。当营业员空闲时,通过叫号选取一位顾客,并为其服务。顾客和营业员的活动过程
描述如下